//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError, AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export interface IClient {
    /**
     * @return OK
     */
    bankGET(id: string): Promise<BankAccountResponseDto>;
    /**
     * @param body (optional) 
     * @return OK
     */
    bankPUT(id: string, body: BankAccountUpdateDto | undefined): Promise<BankAccountResponseDto>;
    /**
     * @return No Content
     */
    bankDELETE(id: string): Promise<void>;
    /**
     * @return OK
     */
    sellerAll(sellerId: string): Promise<BankAccountResponseDto[]>;
    /**
     * @param body (optional) 
     * @return Created
     */
    bankPOST(body: BankAccountCreateDto | undefined): Promise<BankAccountResponseDto>;
    /**
     * @return OK
     */
    verify(id: string): Promise<void>;
    /**
     * @param body (optional) 
     * @return OK
     */
    validate(body: BankAccountCreateDto | undefined): Promise<BankAccountValidationDto>;
    /**
     * @return OK
     */
    walletGET(sellerId: string): Promise<void>;
    /**
     * @param body (optional) 
     * @return OK
     */
    walletPOST(body: WalletCreateDto | undefined): Promise<void>;
    /**
     * @param body (optional) 
     * @return OK
     */
    balancePUT(sellerId: string, body: WalletUpdateDto | undefined): Promise<void>;
    /**
     * @param body (optional) 
     * @return OK
     */
    addFunds(sellerId: string, body: number | undefined): Promise<void>;
    /**
     * @param body (optional) 
     * @return OK
     */
    deductFunds(sellerId: string, body: number | undefined): Promise<void>;
    /**
     * @param body (optional) 
     * @return OK
     */
    walletTransactionPOST(body: CreateTransactionRequest | undefined): Promise<void>;
    /**
     * @return OK
     */
    walletTransactionGET(transactionId: string): Promise<void>;
    /**
     * @return OK
     */
    balanceGET(walletId: string): Promise<void>;
    /**
     * @param status (optional) 
     * @param type (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    history(walletId: string, startDate: Date, endDate: Date, status: TransactionStatus | undefined, type: TransactionType | undefined, page: number | undefined, pageSize: number | undefined): Promise<void>;
    /**
     * @param body (optional) 
     * @return OK
     */
    status(transactionId: string, body: UpdateTransactionStatusRequest | undefined): Promise<void>;
    /**
     * @param body (optional) 
     * @return OK
     */
    withdrawPOST(body: WithdrawCreateDto | undefined): Promise<void>;
    /**
     * @return OK
     */
    withdrawGET(id: string): Promise<void>;
    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    seller(sellerId: string, page: number | undefined, pageSize: number | undefined): Promise<void>;
    /**
     * @param body (optional) 
     * @return OK
     */
    process(id: string, body: WithdrawUpdateDto | undefined): Promise<void>;
    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return OK
     */
    summary(sellerId: string, startDate: Date | undefined, endDate: Date | undefined): Promise<void>;
    /**
     * @return OK
     */
    pending(): Promise<void>;
}

export class Client implements IClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @return OK
     */
    bankGET(id: string, cancelToken?: CancelToken): Promise<BankAccountResponseDto> {
        let url_ = this.baseUrl + "/api/bank/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBankGET(_response);
        });
    }

    protected processBankGET(response: AxiosResponse): Promise<BankAccountResponseDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BankAccountResponseDto.fromJS(resultData200);
            return Promise.resolve<BankAccountResponseDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BankAccountResponseDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    bankPUT(id: string, body: BankAccountUpdateDto | undefined, cancelToken?: CancelToken): Promise<BankAccountResponseDto> {
        let url_ = this.baseUrl + "/api/bank/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBankPUT(_response);
        });
    }

    protected processBankPUT(response: AxiosResponse): Promise<BankAccountResponseDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BankAccountResponseDto.fromJS(resultData200);
            return Promise.resolve<BankAccountResponseDto>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BankAccountResponseDto>(null as any);
    }

    /**
     * @return No Content
     */
    bankDELETE(id: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/bank/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBankDELETE(_response);
        });
    }

    protected processBankDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    sellerAll(sellerId: string, cancelToken?: CancelToken): Promise<BankAccountResponseDto[]> {
        let url_ = this.baseUrl + "/api/bank/seller/{sellerId}";
        if (sellerId === undefined || sellerId === null)
            throw new Error("The parameter 'sellerId' must be defined.");
        url_ = url_.replace("{sellerId}", encodeURIComponent("" + sellerId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSellerAll(_response);
        });
    }

    protected processSellerAll(response: AxiosResponse): Promise<BankAccountResponseDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BankAccountResponseDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<BankAccountResponseDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BankAccountResponseDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    bankPOST(body: BankAccountCreateDto | undefined, cancelToken?: CancelToken): Promise<BankAccountResponseDto> {
        let url_ = this.baseUrl + "/api/bank";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBankPOST(_response);
        });
    }

    protected processBankPOST(response: AxiosResponse): Promise<BankAccountResponseDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = BankAccountResponseDto.fromJS(resultData201);
            return Promise.resolve<BankAccountResponseDto>(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409  = _responseText;
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BankAccountResponseDto>(null as any);
    }

    /**
     * @return OK
     */
    verify(id: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/bank/{id}/verify";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processVerify(_response);
        });
    }

    protected processVerify(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    validate(body: BankAccountCreateDto | undefined, cancelToken?: CancelToken): Promise<BankAccountValidationDto> {
        let url_ = this.baseUrl + "/api/bank/validate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processValidate(_response);
        });
    }

    protected processValidate(response: AxiosResponse): Promise<BankAccountValidationDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BankAccountValidationDto.fromJS(resultData200);
            return Promise.resolve<BankAccountValidationDto>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BankAccountValidationDto>(null as any);
    }

    /**
     * @return OK
     */
    walletGET(sellerId: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/wallet/{sellerId}";
        if (sellerId === undefined || sellerId === null)
            throw new Error("The parameter 'sellerId' must be defined.");
        url_ = url_.replace("{sellerId}", encodeURIComponent("" + sellerId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processWalletGET(_response);
        });
    }

    protected processWalletGET(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    walletPOST(body: WalletCreateDto | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/wallet";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processWalletPOST(_response);
        });
    }

    protected processWalletPOST(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    balancePUT(sellerId: string, body: WalletUpdateDto | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/wallet/{sellerId}/balance";
        if (sellerId === undefined || sellerId === null)
            throw new Error("The parameter 'sellerId' must be defined.");
        url_ = url_.replace("{sellerId}", encodeURIComponent("" + sellerId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBalancePUT(_response);
        });
    }

    protected processBalancePUT(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    addFunds(sellerId: string, body: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/wallet/{sellerId}/add-funds";
        if (sellerId === undefined || sellerId === null)
            throw new Error("The parameter 'sellerId' must be defined.");
        url_ = url_.replace("{sellerId}", encodeURIComponent("" + sellerId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddFunds(_response);
        });
    }

    protected processAddFunds(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    deductFunds(sellerId: string, body: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/wallet/{sellerId}/deduct-funds";
        if (sellerId === undefined || sellerId === null)
            throw new Error("The parameter 'sellerId' must be defined.");
        url_ = url_.replace("{sellerId}", encodeURIComponent("" + sellerId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeductFunds(_response);
        });
    }

    protected processDeductFunds(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    walletTransactionPOST(body: CreateTransactionRequest | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/wallet-transaction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processWalletTransactionPOST(_response);
        });
    }

    protected processWalletTransactionPOST(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    walletTransactionGET(transactionId: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/wallet-transaction/{transactionId}";
        if (transactionId === undefined || transactionId === null)
            throw new Error("The parameter 'transactionId' must be defined.");
        url_ = url_.replace("{transactionId}", encodeURIComponent("" + transactionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processWalletTransactionGET(_response);
        });
    }

    protected processWalletTransactionGET(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    balanceGET(walletId: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/wallet-transaction/wallet/{walletId}/balance";
        if (walletId === undefined || walletId === null)
            throw new Error("The parameter 'walletId' must be defined.");
        url_ = url_.replace("{walletId}", encodeURIComponent("" + walletId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBalanceGET(_response);
        });
    }

    protected processBalanceGET(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param status (optional) 
     * @param type (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    history(walletId: string, startDate: Date, endDate: Date, status: TransactionStatus | undefined, type: TransactionType | undefined, page: number | undefined, pageSize: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/wallet-transaction/wallet/{walletId}/history?";
        if (walletId === undefined || walletId === null)
            throw new Error("The parameter 'walletId' must be defined.");
        url_ = url_.replace("{walletId}", encodeURIComponent("" + walletId));
        if (startDate === undefined || startDate === null)
            throw new Error("The parameter 'startDate' must be defined and cannot be null.");
        else
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === undefined || endDate === null)
            throw new Error("The parameter 'endDate' must be defined and cannot be null.");
        else
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processHistory(_response);
        });
    }

    protected processHistory(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    status(transactionId: string, body: UpdateTransactionStatusRequest | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/wallet-transaction/{transactionId}/status";
        if (transactionId === undefined || transactionId === null)
            throw new Error("The parameter 'transactionId' must be defined.");
        url_ = url_.replace("{transactionId}", encodeURIComponent("" + transactionId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processStatus(_response);
        });
    }

    protected processStatus(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    withdrawPOST(body: WithdrawCreateDto | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/withdraw";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processWithdrawPOST(_response);
        });
    }

    protected processWithdrawPOST(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    withdrawGET(id: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/withdraw/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processWithdrawGET(_response);
        });
    }

    protected processWithdrawGET(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    seller(sellerId: string, page: number | undefined, pageSize: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/withdraw/seller/{sellerId}?";
        if (sellerId === undefined || sellerId === null)
            throw new Error("The parameter 'sellerId' must be defined.");
        url_ = url_.replace("{sellerId}", encodeURIComponent("" + sellerId));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSeller(_response);
        });
    }

    protected processSeller(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    process(id: string, body: WithdrawUpdateDto | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/withdraw/{id}/process";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processProcess(_response);
        });
    }

    protected processProcess(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return OK
     */
    summary(sellerId: string, startDate: Date | undefined, endDate: Date | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/withdraw/summary/{sellerId}?";
        if (sellerId === undefined || sellerId === null)
            throw new Error("The parameter 'sellerId' must be defined.");
        url_ = url_.replace("{sellerId}", encodeURIComponent("" + sellerId));
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSummary(_response);
        });
    }

    protected processSummary(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    pending( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/withdraw/pending";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPending(_response);
        });
    }

    protected processPending(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class BankAccountCreateDto implements IBankAccountCreateDto {
    sellerId?: string;
    bankName?: string | undefined;
    bankCode?: string | undefined;
    accountType?: BankAccountType;
    accountNumber?: string | undefined;
    branchNumber?: string | undefined;
    pixKey?: string | undefined;
    pixKeyType?: PixKeyType;
    documentNumber?: string | undefined;
    accountHolderName?: string | undefined;

    constructor(data?: IBankAccountCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sellerId = _data["sellerId"];
            this.bankName = _data["bankName"];
            this.bankCode = _data["bankCode"];
            this.accountType = _data["accountType"];
            this.accountNumber = _data["accountNumber"];
            this.branchNumber = _data["branchNumber"];
            this.pixKey = _data["pixKey"];
            this.pixKeyType = _data["pixKeyType"];
            this.documentNumber = _data["documentNumber"];
            this.accountHolderName = _data["accountHolderName"];
        }
    }

    static fromJS(data: any): BankAccountCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new BankAccountCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerId"] = this.sellerId;
        data["bankName"] = this.bankName;
        data["bankCode"] = this.bankCode;
        data["accountType"] = this.accountType;
        data["accountNumber"] = this.accountNumber;
        data["branchNumber"] = this.branchNumber;
        data["pixKey"] = this.pixKey;
        data["pixKeyType"] = this.pixKeyType;
        data["documentNumber"] = this.documentNumber;
        data["accountHolderName"] = this.accountHolderName;
        return data;
    }
}

export interface IBankAccountCreateDto {
    sellerId?: string;
    bankName?: string | undefined;
    bankCode?: string | undefined;
    accountType?: BankAccountType;
    accountNumber?: string | undefined;
    branchNumber?: string | undefined;
    pixKey?: string | undefined;
    pixKeyType?: PixKeyType;
    documentNumber?: string | undefined;
    accountHolderName?: string | undefined;
}

export class BankAccountResponseDto implements IBankAccountResponseDto {
    id?: string;
    sellerId?: string;
    bankName?: string | undefined;
    bankCode?: string | undefined;
    accountType?: BankAccountType;
    accountNumber?: string | undefined;
    branchNumber?: string | undefined;
    pixKey?: string | undefined;
    pixKeyType?: PixKeyType;
    documentNumber?: string | undefined;
    accountHolderName?: string | undefined;
    isVerified?: boolean;
    createdAt?: Date;
    lastUpdatedAt?: Date;

    constructor(data?: IBankAccountResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sellerId = _data["sellerId"];
            this.bankName = _data["bankName"];
            this.bankCode = _data["bankCode"];
            this.accountType = _data["accountType"];
            this.accountNumber = _data["accountNumber"];
            this.branchNumber = _data["branchNumber"];
            this.pixKey = _data["pixKey"];
            this.pixKeyType = _data["pixKeyType"];
            this.documentNumber = _data["documentNumber"];
            this.accountHolderName = _data["accountHolderName"];
            this.isVerified = _data["isVerified"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastUpdatedAt = _data["lastUpdatedAt"] ? new Date(_data["lastUpdatedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): BankAccountResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new BankAccountResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sellerId"] = this.sellerId;
        data["bankName"] = this.bankName;
        data["bankCode"] = this.bankCode;
        data["accountType"] = this.accountType;
        data["accountNumber"] = this.accountNumber;
        data["branchNumber"] = this.branchNumber;
        data["pixKey"] = this.pixKey;
        data["pixKeyType"] = this.pixKeyType;
        data["documentNumber"] = this.documentNumber;
        data["accountHolderName"] = this.accountHolderName;
        data["isVerified"] = this.isVerified;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastUpdatedAt"] = this.lastUpdatedAt ? this.lastUpdatedAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IBankAccountResponseDto {
    id?: string;
    sellerId?: string;
    bankName?: string | undefined;
    bankCode?: string | undefined;
    accountType?: BankAccountType;
    accountNumber?: string | undefined;
    branchNumber?: string | undefined;
    pixKey?: string | undefined;
    pixKeyType?: PixKeyType;
    documentNumber?: string | undefined;
    accountHolderName?: string | undefined;
    isVerified?: boolean;
    createdAt?: Date;
    lastUpdatedAt?: Date;
}

export enum BankAccountType {
    _0 = 0,
    _1 = 1,
}

export class BankAccountUpdateDto implements IBankAccountUpdateDto {
    bankName?: string | undefined;
    bankCode?: string | undefined;
    accountType?: BankAccountType;
    accountNumber?: string | undefined;
    branchNumber?: string | undefined;
    pixKey?: string | undefined;
    pixKeyType?: PixKeyType;
    documentNumber?: string | undefined;
    accountHolderName?: string | undefined;

    constructor(data?: IBankAccountUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bankName = _data["bankName"];
            this.bankCode = _data["bankCode"];
            this.accountType = _data["accountType"];
            this.accountNumber = _data["accountNumber"];
            this.branchNumber = _data["branchNumber"];
            this.pixKey = _data["pixKey"];
            this.pixKeyType = _data["pixKeyType"];
            this.documentNumber = _data["documentNumber"];
            this.accountHolderName = _data["accountHolderName"];
        }
    }

    static fromJS(data: any): BankAccountUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new BankAccountUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankName"] = this.bankName;
        data["bankCode"] = this.bankCode;
        data["accountType"] = this.accountType;
        data["accountNumber"] = this.accountNumber;
        data["branchNumber"] = this.branchNumber;
        data["pixKey"] = this.pixKey;
        data["pixKeyType"] = this.pixKeyType;
        data["documentNumber"] = this.documentNumber;
        data["accountHolderName"] = this.accountHolderName;
        return data;
    }
}

export interface IBankAccountUpdateDto {
    bankName?: string | undefined;
    bankCode?: string | undefined;
    accountType?: BankAccountType;
    accountNumber?: string | undefined;
    branchNumber?: string | undefined;
    pixKey?: string | undefined;
    pixKeyType?: PixKeyType;
    documentNumber?: string | undefined;
    accountHolderName?: string | undefined;
}

export class BankAccountValidationDto implements IBankAccountValidationDto {
    isValid?: boolean;
    validationErrors?: string[] | undefined;

    constructor(data?: IBankAccountValidationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isValid = _data["isValid"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
        }
    }

    static fromJS(data: any): BankAccountValidationDto {
        data = typeof data === 'object' ? data : {};
        let result = new BankAccountValidationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isValid"] = this.isValid;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        return data;
    }
}

export interface IBankAccountValidationDto {
    isValid?: boolean;
    validationErrors?: string[] | undefined;
}

export class CreateTransactionRequest implements ICreateTransactionRequest {
    walletId!: string;
    amount!: number;
    type!: TransactionType;
    description!: string;
    reference?: string | undefined;

    constructor(data?: ICreateTransactionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.walletId = _data["walletId"];
            this.amount = _data["amount"];
            this.type = _data["type"];
            this.description = _data["description"];
            this.reference = _data["reference"];
        }
    }

    static fromJS(data: any): CreateTransactionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTransactionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["walletId"] = this.walletId;
        data["amount"] = this.amount;
        data["type"] = this.type;
        data["description"] = this.description;
        data["reference"] = this.reference;
        return data;
    }
}

export interface ICreateTransactionRequest {
    walletId: string;
    amount: number;
    type: TransactionType;
    description: string;
    reference?: string | undefined;
}

export enum PixKeyType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export enum TransactionStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export enum TransactionType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class UpdateTransactionStatusRequest implements IUpdateTransactionStatusRequest {
    status!: TransactionStatus;
    reason?: string | undefined;

    constructor(data?: IUpdateTransactionStatusRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.reason = _data["reason"];
        }
    }

    static fromJS(data: any): UpdateTransactionStatusRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTransactionStatusRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["reason"] = this.reason;
        return data;
    }
}

export interface IUpdateTransactionStatusRequest {
    status: TransactionStatus;
    reason?: string | undefined;
}

export class WalletCreateDto implements IWalletCreateDto {
    sellerId?: string;

    constructor(data?: IWalletCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sellerId = _data["sellerId"];
        }
    }

    static fromJS(data: any): WalletCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new WalletCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerId"] = this.sellerId;
        return data;
    }
}

export interface IWalletCreateDto {
    sellerId?: string;
}

export class WalletUpdateDto implements IWalletUpdateDto {
    availableBalance?: number;
    pendingBalance?: number;

    constructor(data?: IWalletUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.availableBalance = _data["availableBalance"];
            this.pendingBalance = _data["pendingBalance"];
        }
    }

    static fromJS(data: any): WalletUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new WalletUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["availableBalance"] = this.availableBalance;
        data["pendingBalance"] = this.pendingBalance;
        return data;
    }
}

export interface IWalletUpdateDto {
    availableBalance?: number;
    pendingBalance?: number;
}

export class WithdrawCreateDto implements IWithdrawCreateDto {
    sellerId!: string;
    amount!: number;
    withdrawMethod!: string;
    bankAccountId!: string;

    constructor(data?: IWithdrawCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sellerId = _data["sellerId"];
            this.amount = _data["amount"];
            this.withdrawMethod = _data["withdrawMethod"];
            this.bankAccountId = _data["bankAccountId"];
        }
    }

    static fromJS(data: any): WithdrawCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new WithdrawCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerId"] = this.sellerId;
        data["amount"] = this.amount;
        data["withdrawMethod"] = this.withdrawMethod;
        data["bankAccountId"] = this.bankAccountId;
        return data;
    }
}

export interface IWithdrawCreateDto {
    sellerId: string;
    amount: number;
    withdrawMethod: string;
    bankAccountId: string;
}

export class WithdrawUpdateDto implements IWithdrawUpdateDto {
    status!: string;
    failureReason?: string | undefined;
    transactionReceipt?: string | undefined;

    constructor(data?: IWithdrawUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.failureReason = _data["failureReason"];
            this.transactionReceipt = _data["transactionReceipt"];
        }
    }

    static fromJS(data: any): WithdrawUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new WithdrawUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["failureReason"] = this.failureReason;
        data["transactionReceipt"] = this.transactionReceipt;
        return data;
    }
}

export interface IWithdrawUpdateDto {
    status: string;
    failureReason?: string | undefined;
    transactionReceipt?: string | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}