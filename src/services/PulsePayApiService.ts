//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError, AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export interface IClient {
    /**
     * @return OK
     */
    bankGET(id: string): Promise<BankAccountResponseDto>;
    /**
     * @param body (optional) 
     * @return OK
     */
    bankPUT(id: string, body: BankAccountUpdateDto | undefined): Promise<BankAccountResponseDto>;
    /**
     * @return OK
     */
    sellerAll(sellerId: string): Promise<BankAccountResponseDto[]>;
    /**
     * @param body (optional) 
     * @return Created
     */
    bankPOST(body: BankAccountCreateDto | undefined): Promise<BankAccountResponseDto>;
    /**
     * @param id (optional) 
     * @return No Content
     */
    bankDELETE(id: string | undefined, sellerId: string): Promise<void>;
    /**
     * @return OK
     */
    verify(id: string): Promise<void>;
    /**
     * @param body (optional) 
     * @return OK
     */
    validate(body: BankAccountCreateDto | undefined): Promise<BankAccountValidationDto>;
    /**
     * @return OK
     */
    walletsGET(id: string): Promise<WalletDtoApiResponse>;
    /**
     * @return OK
     */
    seller(sellerId: string): Promise<WalletDtoIEnumerableApiResponse>;
    /**
     * @return OK
     */
    type(sellerId: string, walletType: WalletType): Promise<WalletDtoApiResponse>;
    /**
     * @param count (optional) 
     * @return OK
     */
    withTransactions(id: string, count: number | undefined): Promise<WalletWithTransactionsDtoApiResponse>;
    /**
     * @param body (optional) 
     * @return Created
     */
    walletsPOST(body: WalletCreateDto | undefined): Promise<WalletDtoApiResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    balancePUT(id: string, body: WalletUpdateDto | undefined): Promise<WalletDtoApiResponse>;
    /**
     * @return OK
     */
    balanceGET(id: string): Promise<DecimalApiResponse>;
    /**
     * @param sellerId (optional) 
     * @return OK
     */
    default(id: string, sellerId: string | undefined): Promise<WalletDtoApiResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    deposits(id: string, body: FundsOperationRequest | undefined): Promise<WalletDtoApiResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    withdrawals(id: string, body: FundsOperationRequest | undefined): Promise<WalletDtoApiResponse>;
    /**
     * @param sourceWalletId (optional) 
     * @param destinationWalletId (optional) 
     * @param body (optional) 
     * @return OK
     */
    transfer(sourceWalletId: string | undefined, destinationWalletId: string | undefined, body: FundsOperationRequest | undefined): Promise<ObjectApiResponse>;
    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    transactions(id: string, startDate: Date | undefined, endDate: Date | undefined, page: number | undefined, pageSize: number | undefined): Promise<WalletTransactionDtoListApiResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    walletTransactionsPOST(body: CreateTransactionRequest | undefined): Promise<void>;
    /**
     * @return OK
     */
    walletTransactionsGET(transactionId: string): Promise<void>;
    /**
     * @return OK
     */
    balanceGET2(walletId: string): Promise<void>;
    /**
     * @param status (optional) 
     * @param type (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    history(walletId: string, startDate: Date, endDate: Date, status: TransactionStatus | undefined, type: TransactionType | undefined, page: number | undefined, pageSize: number | undefined): Promise<void>;
    /**
     * @param body (optional) 
     * @return OK
     */
    status(transactionId: string, body: UpdateTransactionStatusRequest | undefined): Promise<void>;
}

export class Client implements IClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @return OK
     */
    bankGET(id: string, cancelToken?: CancelToken): Promise<BankAccountResponseDto> {
        let url_ = this.baseUrl + "/api/bank/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBankGET(_response);
        });
    }

    protected processBankGET(response: AxiosResponse): Promise<BankAccountResponseDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BankAccountResponseDto.fromJS(resultData200);
            return Promise.resolve<BankAccountResponseDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BankAccountResponseDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    bankPUT(id: string, body: BankAccountUpdateDto | undefined, cancelToken?: CancelToken): Promise<BankAccountResponseDto> {
        let url_ = this.baseUrl + "/api/bank/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBankPUT(_response);
        });
    }

    protected processBankPUT(response: AxiosResponse): Promise<BankAccountResponseDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BankAccountResponseDto.fromJS(resultData200);
            return Promise.resolve<BankAccountResponseDto>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BankAccountResponseDto>(null as any);
    }

    /**
     * @return OK
     */
    sellerAll(sellerId: string, cancelToken?: CancelToken): Promise<BankAccountResponseDto[]> {
        let url_ = this.baseUrl + "/api/bank/seller/{sellerId}";
        if (sellerId === undefined || sellerId === null)
            throw new Error("The parameter 'sellerId' must be defined.");
        url_ = url_.replace("{sellerId}", encodeURIComponent("" + sellerId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSellerAll(_response);
        });
    }

    protected processSellerAll(response: AxiosResponse): Promise<BankAccountResponseDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BankAccountResponseDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<BankAccountResponseDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BankAccountResponseDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    bankPOST(body: BankAccountCreateDto | undefined, cancelToken?: CancelToken): Promise<BankAccountResponseDto> {
        let url_ = this.baseUrl + "/api/bank";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBankPOST(_response);
        });
    }

    protected processBankPOST(response: AxiosResponse): Promise<BankAccountResponseDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = BankAccountResponseDto.fromJS(resultData201);
            return Promise.resolve<BankAccountResponseDto>(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409  = _responseText;
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BankAccountResponseDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return No Content
     */
    bankDELETE(id: string | undefined, sellerId: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/bank/{sellerId}?";
        if (sellerId === undefined || sellerId === null)
            throw new Error("The parameter 'sellerId' must be defined.");
        url_ = url_.replace("{sellerId}", encodeURIComponent("" + sellerId));
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBankDELETE(_response);
        });
    }

    protected processBankDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    verify(id: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/bank/{id}/verify";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processVerify(_response);
        });
    }

    protected processVerify(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    validate(body: BankAccountCreateDto | undefined, cancelToken?: CancelToken): Promise<BankAccountValidationDto> {
        let url_ = this.baseUrl + "/api/bank/validate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processValidate(_response);
        });
    }

    protected processValidate(response: AxiosResponse): Promise<BankAccountValidationDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BankAccountValidationDto.fromJS(resultData200);
            return Promise.resolve<BankAccountValidationDto>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BankAccountValidationDto>(null as any);
    }

    /**
     * @return OK
     */
    walletsGET(id: string, cancelToken?: CancelToken): Promise<WalletDtoApiResponse> {
        let url_ = this.baseUrl + "/api/wallets/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processWalletsGET(_response);
        });
    }

    protected processWalletsGET(response: AxiosResponse): Promise<WalletDtoApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = WalletDtoApiResponse.fromJS(resultData200);
            return Promise.resolve<WalletDtoApiResponse>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectApiResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectApiResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WalletDtoApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    seller(sellerId: string, cancelToken?: CancelToken): Promise<WalletDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/wallets/seller/{sellerId}";
        if (sellerId === undefined || sellerId === null)
            throw new Error("The parameter 'sellerId' must be defined.");
        url_ = url_.replace("{sellerId}", encodeURIComponent("" + sellerId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSeller(_response);
        });
    }

    protected processSeller(response: AxiosResponse): Promise<WalletDtoIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = WalletDtoIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<WalletDtoIEnumerableApiResponse>(result200);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectApiResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WalletDtoIEnumerableApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    type(sellerId: string, walletType: WalletType, cancelToken?: CancelToken): Promise<WalletDtoApiResponse> {
        let url_ = this.baseUrl + "/api/wallets/seller/{sellerId}/type/{walletType}";
        if (sellerId === undefined || sellerId === null)
            throw new Error("The parameter 'sellerId' must be defined.");
        url_ = url_.replace("{sellerId}", encodeURIComponent("" + sellerId));
        if (walletType === undefined || walletType === null)
            throw new Error("The parameter 'walletType' must be defined.");
        url_ = url_.replace("{walletType}", encodeURIComponent("" + walletType));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processType(_response);
        });
    }

    protected processType(response: AxiosResponse): Promise<WalletDtoApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = WalletDtoApiResponse.fromJS(resultData200);
            return Promise.resolve<WalletDtoApiResponse>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectApiResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectApiResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WalletDtoApiResponse>(null as any);
    }

    /**
     * @param count (optional) 
     * @return OK
     */
    withTransactions(id: string, count: number | undefined, cancelToken?: CancelToken): Promise<WalletWithTransactionsDtoApiResponse> {
        let url_ = this.baseUrl + "/api/wallets/{id}/with-transactions?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processWithTransactions(_response);
        });
    }

    protected processWithTransactions(response: AxiosResponse): Promise<WalletWithTransactionsDtoApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = WalletWithTransactionsDtoApiResponse.fromJS(resultData200);
            return Promise.resolve<WalletWithTransactionsDtoApiResponse>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectApiResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectApiResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WalletWithTransactionsDtoApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    walletsPOST(body: WalletCreateDto | undefined, cancelToken?: CancelToken): Promise<WalletDtoApiResponse> {
        let url_ = this.baseUrl + "/api/wallets";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processWalletsPOST(_response);
        });
    }

    protected processWalletsPOST(response: AxiosResponse): Promise<WalletDtoApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = WalletDtoApiResponse.fromJS(resultData201);
            return Promise.resolve<WalletDtoApiResponse>(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ObjectApiResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409  = _responseText;
            result409 = ObjectApiResponse.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectApiResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WalletDtoApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    balancePUT(id: string, body: WalletUpdateDto | undefined, cancelToken?: CancelToken): Promise<WalletDtoApiResponse> {
        let url_ = this.baseUrl + "/api/wallets/{id}/balance";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBalancePUT(_response);
        });
    }

    protected processBalancePUT(response: AxiosResponse): Promise<WalletDtoApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = WalletDtoApiResponse.fromJS(resultData200);
            return Promise.resolve<WalletDtoApiResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ObjectApiResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectApiResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectApiResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WalletDtoApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    balanceGET(id: string, cancelToken?: CancelToken): Promise<DecimalApiResponse> {
        let url_ = this.baseUrl + "/api/wallets/{id}/balance";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBalanceGET(_response);
        });
    }

    protected processBalanceGET(response: AxiosResponse): Promise<DecimalApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DecimalApiResponse.fromJS(resultData200);
            return Promise.resolve<DecimalApiResponse>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectApiResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectApiResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DecimalApiResponse>(null as any);
    }

    /**
     * @param sellerId (optional) 
     * @return OK
     */
    default(id: string, sellerId: string | undefined, cancelToken?: CancelToken): Promise<WalletDtoApiResponse> {
        let url_ = this.baseUrl + "/api/wallets/{id}/default?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (sellerId === null)
            throw new Error("The parameter 'sellerId' cannot be null.");
        else if (sellerId !== undefined)
            url_ += "sellerId=" + encodeURIComponent("" + sellerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDefault(_response);
        });
    }

    protected processDefault(response: AxiosResponse): Promise<WalletDtoApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = WalletDtoApiResponse.fromJS(resultData200);
            return Promise.resolve<WalletDtoApiResponse>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectApiResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectApiResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WalletDtoApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    deposits(id: string, body: FundsOperationRequest | undefined, cancelToken?: CancelToken): Promise<WalletDtoApiResponse> {
        let url_ = this.baseUrl + "/api/wallets/{id}/deposits";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeposits(_response);
        });
    }

    protected processDeposits(response: AxiosResponse): Promise<WalletDtoApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = WalletDtoApiResponse.fromJS(resultData200);
            return Promise.resolve<WalletDtoApiResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ObjectApiResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectApiResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectApiResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WalletDtoApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    withdrawals(id: string, body: FundsOperationRequest | undefined, cancelToken?: CancelToken): Promise<WalletDtoApiResponse> {
        let url_ = this.baseUrl + "/api/wallets/{id}/withdrawals";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processWithdrawals(_response);
        });
    }

    protected processWithdrawals(response: AxiosResponse): Promise<WalletDtoApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = WalletDtoApiResponse.fromJS(resultData200);
            return Promise.resolve<WalletDtoApiResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ObjectApiResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectApiResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectApiResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WalletDtoApiResponse>(null as any);
    }

    /**
     * @param sourceWalletId (optional) 
     * @param destinationWalletId (optional) 
     * @param body (optional) 
     * @return OK
     */
    transfer(sourceWalletId: string | undefined, destinationWalletId: string | undefined, body: FundsOperationRequest | undefined, cancelToken?: CancelToken): Promise<ObjectApiResponse> {
        let url_ = this.baseUrl + "/api/wallets/transfer?";
        if (sourceWalletId === null)
            throw new Error("The parameter 'sourceWalletId' cannot be null.");
        else if (sourceWalletId !== undefined)
            url_ += "sourceWalletId=" + encodeURIComponent("" + sourceWalletId) + "&";
        if (destinationWalletId === null)
            throw new Error("The parameter 'destinationWalletId' cannot be null.");
        else if (destinationWalletId !== undefined)
            url_ += "destinationWalletId=" + encodeURIComponent("" + destinationWalletId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTransfer(_response);
        });
    }

    protected processTransfer(response: AxiosResponse): Promise<ObjectApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ObjectApiResponse.fromJS(resultData200);
            return Promise.resolve<ObjectApiResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ObjectApiResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectApiResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectApiResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ObjectApiResponse>(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    transactions(id: string, startDate: Date | undefined, endDate: Date | undefined, page: number | undefined, pageSize: number | undefined, cancelToken?: CancelToken): Promise<WalletTransactionDtoListApiResponse> {
        let url_ = this.baseUrl + "/api/wallets/{id}/transactions?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTransactions(_response);
        });
    }

    protected processTransactions(response: AxiosResponse): Promise<WalletTransactionDtoListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = WalletTransactionDtoListApiResponse.fromJS(resultData200);
            return Promise.resolve<WalletTransactionDtoListApiResponse>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectApiResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectApiResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WalletTransactionDtoListApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    walletTransactionsPOST(body: CreateTransactionRequest | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/wallet-transactions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processWalletTransactionsPOST(_response);
        });
    }

    protected processWalletTransactionsPOST(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    walletTransactionsGET(transactionId: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/wallet-transactions/{transactionId}";
        if (transactionId === undefined || transactionId === null)
            throw new Error("The parameter 'transactionId' must be defined.");
        url_ = url_.replace("{transactionId}", encodeURIComponent("" + transactionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processWalletTransactionsGET(_response);
        });
    }

    protected processWalletTransactionsGET(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    balanceGET2(walletId: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/wallet-transactions/wallet/{walletId}/balance";
        if (walletId === undefined || walletId === null)
            throw new Error("The parameter 'walletId' must be defined.");
        url_ = url_.replace("{walletId}", encodeURIComponent("" + walletId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBalanceGET2(_response);
        });
    }

    protected processBalanceGET2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param status (optional) 
     * @param type (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    history(walletId: string, startDate: Date, endDate: Date, status: TransactionStatus | undefined, type: TransactionType | undefined, page: number | undefined, pageSize: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/wallet-transactions/wallet/{walletId}/history?";
        if (walletId === undefined || walletId === null)
            throw new Error("The parameter 'walletId' must be defined.");
        url_ = url_.replace("{walletId}", encodeURIComponent("" + walletId));
        if (startDate === undefined || startDate === null)
            throw new Error("The parameter 'startDate' must be defined and cannot be null.");
        else
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === undefined || endDate === null)
            throw new Error("The parameter 'endDate' must be defined and cannot be null.");
        else
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processHistory(_response);
        });
    }

    protected processHistory(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    status(transactionId: string, body: UpdateTransactionStatusRequest | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/wallet-transactions/{transactionId}/status";
        if (transactionId === undefined || transactionId === null)
            throw new Error("The parameter 'transactionId' must be defined.");
        url_ = url_.replace("{transactionId}", encodeURIComponent("" + transactionId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processStatus(_response);
        });
    }

    protected processStatus(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class BankAccountCreateDto implements IBankAccountCreateDto {
    sellerId?: string;
    bankName?: string | undefined;
    bankCode?: string | undefined;
    accountType?: BankAccountType;
    accountNumber?: string | undefined;
    branchNumber?: string | undefined;
    pixKey?: string | undefined;
    pixKeyType?: PixKeyType;
    documentNumber?: string | undefined;
    accountHolderName?: string | undefined;

    constructor(data?: IBankAccountCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sellerId = _data["sellerId"];
            this.bankName = _data["bankName"];
            this.bankCode = _data["bankCode"];
            this.accountType = _data["accountType"];
            this.accountNumber = _data["accountNumber"];
            this.branchNumber = _data["branchNumber"];
            this.pixKey = _data["pixKey"];
            this.pixKeyType = _data["pixKeyType"];
            this.documentNumber = _data["documentNumber"];
            this.accountHolderName = _data["accountHolderName"];
        }
    }

    static fromJS(data: any): BankAccountCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new BankAccountCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerId"] = this.sellerId;
        data["bankName"] = this.bankName;
        data["bankCode"] = this.bankCode;
        data["accountType"] = this.accountType;
        data["accountNumber"] = this.accountNumber;
        data["branchNumber"] = this.branchNumber;
        data["pixKey"] = this.pixKey;
        data["pixKeyType"] = this.pixKeyType;
        data["documentNumber"] = this.documentNumber;
        data["accountHolderName"] = this.accountHolderName;
        return data;
    }
}

export interface IBankAccountCreateDto {
    sellerId?: string;
    bankName?: string | undefined;
    bankCode?: string | undefined;
    accountType?: BankAccountType;
    accountNumber?: string | undefined;
    branchNumber?: string | undefined;
    pixKey?: string | undefined;
    pixKeyType?: PixKeyType;
    documentNumber?: string | undefined;
    accountHolderName?: string | undefined;
}

export class BankAccountResponseDto implements IBankAccountResponseDto {
    id?: string;
    sellerId?: string;
    bankName?: string | undefined;
    bankCode?: string | undefined;
    accountType?: BankAccountType;
    accountNumber?: string | undefined;
    branchNumber?: string | undefined;
    pixKey?: string | undefined;
    pixKeyType?: PixKeyType;
    documentNumber?: string | undefined;
    accountHolderName?: string | undefined;
    isVerified?: boolean;
    createdAt?: Date;
    lastUpdatedAt?: Date;

    constructor(data?: IBankAccountResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sellerId = _data["sellerId"];
            this.bankName = _data["bankName"];
            this.bankCode = _data["bankCode"];
            this.accountType = _data["accountType"];
            this.accountNumber = _data["accountNumber"];
            this.branchNumber = _data["branchNumber"];
            this.pixKey = _data["pixKey"];
            this.pixKeyType = _data["pixKeyType"];
            this.documentNumber = _data["documentNumber"];
            this.accountHolderName = _data["accountHolderName"];
            this.isVerified = _data["isVerified"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastUpdatedAt = _data["lastUpdatedAt"] ? new Date(_data["lastUpdatedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): BankAccountResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new BankAccountResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sellerId"] = this.sellerId;
        data["bankName"] = this.bankName;
        data["bankCode"] = this.bankCode;
        data["accountType"] = this.accountType;
        data["accountNumber"] = this.accountNumber;
        data["branchNumber"] = this.branchNumber;
        data["pixKey"] = this.pixKey;
        data["pixKeyType"] = this.pixKeyType;
        data["documentNumber"] = this.documentNumber;
        data["accountHolderName"] = this.accountHolderName;
        data["isVerified"] = this.isVerified;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastUpdatedAt"] = this.lastUpdatedAt ? this.lastUpdatedAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IBankAccountResponseDto {
    id?: string;
    sellerId?: string;
    bankName?: string | undefined;
    bankCode?: string | undefined;
    accountType?: BankAccountType;
    accountNumber?: string | undefined;
    branchNumber?: string | undefined;
    pixKey?: string | undefined;
    pixKeyType?: PixKeyType;
    documentNumber?: string | undefined;
    accountHolderName?: string | undefined;
    isVerified?: boolean;
    createdAt?: Date;
    lastUpdatedAt?: Date;
}

export enum BankAccountType {
    _0 = 0,
    _1 = 1,
}

export class BankAccountUpdateDto implements IBankAccountUpdateDto {
    bankName?: string | undefined;
    bankCode?: string | undefined;
    accountType?: BankAccountType;
    accountNumber?: string | undefined;
    branchNumber?: string | undefined;
    pixKey?: string | undefined;
    pixKeyType?: PixKeyType;
    documentNumber?: string | undefined;
    accountHolderName?: string | undefined;

    constructor(data?: IBankAccountUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bankName = _data["bankName"];
            this.bankCode = _data["bankCode"];
            this.accountType = _data["accountType"];
            this.accountNumber = _data["accountNumber"];
            this.branchNumber = _data["branchNumber"];
            this.pixKey = _data["pixKey"];
            this.pixKeyType = _data["pixKeyType"];
            this.documentNumber = _data["documentNumber"];
            this.accountHolderName = _data["accountHolderName"];
        }
    }

    static fromJS(data: any): BankAccountUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new BankAccountUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankName"] = this.bankName;
        data["bankCode"] = this.bankCode;
        data["accountType"] = this.accountType;
        data["accountNumber"] = this.accountNumber;
        data["branchNumber"] = this.branchNumber;
        data["pixKey"] = this.pixKey;
        data["pixKeyType"] = this.pixKeyType;
        data["documentNumber"] = this.documentNumber;
        data["accountHolderName"] = this.accountHolderName;
        return data;
    }
}

export interface IBankAccountUpdateDto {
    bankName?: string | undefined;
    bankCode?: string | undefined;
    accountType?: BankAccountType;
    accountNumber?: string | undefined;
    branchNumber?: string | undefined;
    pixKey?: string | undefined;
    pixKeyType?: PixKeyType;
    documentNumber?: string | undefined;
    accountHolderName?: string | undefined;
}

export class BankAccountValidationDto implements IBankAccountValidationDto {
    isValid?: boolean;
    validationErrors?: string[] | undefined;

    constructor(data?: IBankAccountValidationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isValid = _data["isValid"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
        }
    }

    static fromJS(data: any): BankAccountValidationDto {
        data = typeof data === 'object' ? data : {};
        let result = new BankAccountValidationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isValid"] = this.isValid;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        return data;
    }
}

export interface IBankAccountValidationDto {
    isValid?: boolean;
    validationErrors?: string[] | undefined;
}

export class CreateTransactionRequest implements ICreateTransactionRequest {
    walletId!: string;
    amount!: number;
    type!: TransactionType;
    description!: string;
    reference?: string | undefined;

    constructor(data?: ICreateTransactionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.walletId = _data["walletId"];
            this.amount = _data["amount"];
            this.type = _data["type"];
            this.description = _data["description"];
            this.reference = _data["reference"];
        }
    }

    static fromJS(data: any): CreateTransactionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTransactionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["walletId"] = this.walletId;
        data["amount"] = this.amount;
        data["type"] = this.type;
        data["description"] = this.description;
        data["reference"] = this.reference;
        return data;
    }
}

export interface ICreateTransactionRequest {
    walletId: string;
    amount: number;
    type: TransactionType;
    description: string;
    reference?: string | undefined;
}

export class DecimalApiResponse implements IDecimalApiResponse {
    success?: boolean;
    statusCode?: HttpStatusCode;
    message?: string | undefined;
    data?: number;

    constructor(data?: IDecimalApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.statusCode = _data["statusCode"];
            this.message = _data["message"];
            this.data = _data["data"];
        }
    }

    static fromJS(data: any): DecimalApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DecimalApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["statusCode"] = this.statusCode;
        data["message"] = this.message;
        data["data"] = this.data;
        return data;
    }
}

export interface IDecimalApiResponse {
    success?: boolean;
    statusCode?: HttpStatusCode;
    message?: string | undefined;
    data?: number;
}

export class FundsOperationRequest implements IFundsOperationRequest {
    amount!: number;
    description?: string | undefined;
    reference?: string | undefined;

    constructor(data?: IFundsOperationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.amount = _data["amount"];
            this.description = _data["description"];
            this.reference = _data["reference"];
        }
    }

    static fromJS(data: any): FundsOperationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new FundsOperationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["description"] = this.description;
        data["reference"] = this.reference;
        return data;
    }
}

export interface IFundsOperationRequest {
    amount: number;
    description?: string | undefined;
    reference?: string | undefined;
}

export enum HttpStatusCode {
    _100 = 100,
    _101 = 101,
    _102 = 102,
    _103 = 103,
    _200 = 200,
    _201 = 201,
    _202 = 202,
    _203 = 203,
    _204 = 204,
    _205 = 205,
    _206 = 206,
    _207 = 207,
    _208 = 208,
    _226 = 226,
    _300 = 300,
    _301 = 301,
    _302 = 302,
    _303 = 303,
    _304 = 304,
    _305 = 305,
    _306 = 306,
    _307 = 307,
    _308 = 308,
    _400 = 400,
    _401 = 401,
    _402 = 402,
    _403 = 403,
    _404 = 404,
    _405 = 405,
    _406 = 406,
    _407 = 407,
    _408 = 408,
    _409 = 409,
    _410 = 410,
    _411 = 411,
    _412 = 412,
    _413 = 413,
    _414 = 414,
    _415 = 415,
    _416 = 416,
    _417 = 417,
    _421 = 421,
    _422 = 422,
    _423 = 423,
    _424 = 424,
    _426 = 426,
    _428 = 428,
    _429 = 429,
    _431 = 431,
    _451 = 451,
    _500 = 500,
    _501 = 501,
    _502 = 502,
    _503 = 503,
    _504 = 504,
    _505 = 505,
    _506 = 506,
    _507 = 507,
    _508 = 508,
    _510 = 510,
    _511 = 511,
}

export class ObjectApiResponse implements IObjectApiResponse {
    success?: boolean;
    statusCode?: HttpStatusCode;
    message?: string | undefined;
    data?: any | undefined;

    constructor(data?: IObjectApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.statusCode = _data["statusCode"];
            this.message = _data["message"];
            this.data = _data["data"];
        }
    }

    static fromJS(data: any): ObjectApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["statusCode"] = this.statusCode;
        data["message"] = this.message;
        data["data"] = this.data;
        return data;
    }
}

export interface IObjectApiResponse {
    success?: boolean;
    statusCode?: HttpStatusCode;
    message?: string | undefined;
    data?: any | undefined;
}

export enum PixKeyType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export enum TransactionStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export enum TransactionType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
}

export class UpdateTransactionStatusRequest implements IUpdateTransactionStatusRequest {
    status!: TransactionStatus;
    reason?: string | undefined;

    constructor(data?: IUpdateTransactionStatusRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.reason = _data["reason"];
        }
    }

    static fromJS(data: any): UpdateTransactionStatusRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTransactionStatusRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["reason"] = this.reason;
        return data;
    }
}

export interface IUpdateTransactionStatusRequest {
    status: TransactionStatus;
    reason?: string | undefined;
}

export class WalletCreateDto implements IWalletCreateDto {
    sellerId!: string;
    walletType!: WalletType;
    isDefault?: boolean;

    constructor(data?: IWalletCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sellerId = _data["sellerId"];
            this.walletType = _data["walletType"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): WalletCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new WalletCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerId"] = this.sellerId;
        data["walletType"] = this.walletType;
        data["isDefault"] = this.isDefault;
        return data;
    }
}

export interface IWalletCreateDto {
    sellerId: string;
    walletType: WalletType;
    isDefault?: boolean;
}

export class WalletDto implements IWalletDto {
    id?: string;
    sellerId?: string;
    availableBalance?: number;
    pendingBalance?: number;
    totalBalance?: number;
    walletType?: WalletType;
    isDefault?: boolean;
    lastUpdateAt?: Date;
    createdAt?: Date;

    constructor(data?: IWalletDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sellerId = _data["sellerId"];
            this.availableBalance = _data["availableBalance"];
            this.pendingBalance = _data["pendingBalance"];
            this.totalBalance = _data["totalBalance"];
            this.walletType = _data["walletType"];
            this.isDefault = _data["isDefault"];
            this.lastUpdateAt = _data["lastUpdateAt"] ? new Date(_data["lastUpdateAt"].toString()) : <any>undefined;
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): WalletDto {
        data = typeof data === 'object' ? data : {};
        let result = new WalletDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sellerId"] = this.sellerId;
        data["availableBalance"] = this.availableBalance;
        data["pendingBalance"] = this.pendingBalance;
        data["totalBalance"] = this.totalBalance;
        data["walletType"] = this.walletType;
        data["isDefault"] = this.isDefault;
        data["lastUpdateAt"] = this.lastUpdateAt ? this.lastUpdateAt.toISOString() : <any>undefined;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IWalletDto {
    id?: string;
    sellerId?: string;
    availableBalance?: number;
    pendingBalance?: number;
    totalBalance?: number;
    walletType?: WalletType;
    isDefault?: boolean;
    lastUpdateAt?: Date;
    createdAt?: Date;
}

export class WalletDtoApiResponse implements IWalletDtoApiResponse {
    success?: boolean;
    statusCode?: HttpStatusCode;
    message?: string | undefined;
    data?: WalletDto;

    constructor(data?: IWalletDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.statusCode = _data["statusCode"];
            this.message = _data["message"];
            this.data = _data["data"] ? WalletDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): WalletDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new WalletDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["statusCode"] = this.statusCode;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IWalletDtoApiResponse {
    success?: boolean;
    statusCode?: HttpStatusCode;
    message?: string | undefined;
    data?: WalletDto;
}

export class WalletDtoIEnumerableApiResponse implements IWalletDtoIEnumerableApiResponse {
    success?: boolean;
    statusCode?: HttpStatusCode;
    message?: string | undefined;
    data?: WalletDto[] | undefined;

    constructor(data?: IWalletDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.statusCode = _data["statusCode"];
            this.message = _data["message"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(WalletDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WalletDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new WalletDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["statusCode"] = this.statusCode;
        data["message"] = this.message;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWalletDtoIEnumerableApiResponse {
    success?: boolean;
    statusCode?: HttpStatusCode;
    message?: string | undefined;
    data?: WalletDto[] | undefined;
}

export class WalletTransactionDto implements IWalletTransactionDto {
    id?: string;
    walletId?: string;
    amount?: number;
    type?: string | undefined;
    status?: string | undefined;
    description?: string | undefined;
    reference?: string | undefined;
    createdAt?: Date;
    processedAt?: Date | undefined;

    constructor(data?: IWalletTransactionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.walletId = _data["walletId"];
            this.amount = _data["amount"];
            this.type = _data["type"];
            this.status = _data["status"];
            this.description = _data["description"];
            this.reference = _data["reference"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.processedAt = _data["processedAt"] ? new Date(_data["processedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): WalletTransactionDto {
        data = typeof data === 'object' ? data : {};
        let result = new WalletTransactionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["walletId"] = this.walletId;
        data["amount"] = this.amount;
        data["type"] = this.type;
        data["status"] = this.status;
        data["description"] = this.description;
        data["reference"] = this.reference;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["processedAt"] = this.processedAt ? this.processedAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IWalletTransactionDto {
    id?: string;
    walletId?: string;
    amount?: number;
    type?: string | undefined;
    status?: string | undefined;
    description?: string | undefined;
    reference?: string | undefined;
    createdAt?: Date;
    processedAt?: Date | undefined;
}

export class WalletTransactionDtoListApiResponse implements IWalletTransactionDtoListApiResponse {
    success?: boolean;
    statusCode?: HttpStatusCode;
    message?: string | undefined;
    data?: WalletTransactionDto[] | undefined;

    constructor(data?: IWalletTransactionDtoListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.statusCode = _data["statusCode"];
            this.message = _data["message"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(WalletTransactionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WalletTransactionDtoListApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new WalletTransactionDtoListApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["statusCode"] = this.statusCode;
        data["message"] = this.message;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWalletTransactionDtoListApiResponse {
    success?: boolean;
    statusCode?: HttpStatusCode;
    message?: string | undefined;
    data?: WalletTransactionDto[] | undefined;
}

export enum WalletType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class WalletUpdateDto implements IWalletUpdateDto {
    availableBalance!: number;
    pendingBalance!: number;

    constructor(data?: IWalletUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.availableBalance = _data["availableBalance"];
            this.pendingBalance = _data["pendingBalance"];
        }
    }

    static fromJS(data: any): WalletUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new WalletUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["availableBalance"] = this.availableBalance;
        data["pendingBalance"] = this.pendingBalance;
        return data;
    }
}

export interface IWalletUpdateDto {
    availableBalance: number;
    pendingBalance: number;
}

export class WalletWithTransactionsDto implements IWalletWithTransactionsDto {
    wallet?: WalletDto;
    recentTransactions?: WalletTransactionDto[] | undefined;

    constructor(data?: IWalletWithTransactionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wallet = _data["wallet"] ? WalletDto.fromJS(_data["wallet"]) : <any>undefined;
            if (Array.isArray(_data["recentTransactions"])) {
                this.recentTransactions = [] as any;
                for (let item of _data["recentTransactions"])
                    this.recentTransactions!.push(WalletTransactionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WalletWithTransactionsDto {
        data = typeof data === 'object' ? data : {};
        let result = new WalletWithTransactionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wallet"] = this.wallet ? this.wallet.toJSON() : <any>undefined;
        if (Array.isArray(this.recentTransactions)) {
            data["recentTransactions"] = [];
            for (let item of this.recentTransactions)
                data["recentTransactions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWalletWithTransactionsDto {
    wallet?: WalletDto;
    recentTransactions?: WalletTransactionDto[] | undefined;
}

export class WalletWithTransactionsDtoApiResponse implements IWalletWithTransactionsDtoApiResponse {
    success?: boolean;
    statusCode?: HttpStatusCode;
    message?: string | undefined;
    data?: WalletWithTransactionsDto;

    constructor(data?: IWalletWithTransactionsDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.statusCode = _data["statusCode"];
            this.message = _data["message"];
            this.data = _data["data"] ? WalletWithTransactionsDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): WalletWithTransactionsDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new WalletWithTransactionsDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["statusCode"] = this.statusCode;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IWalletWithTransactionsDtoApiResponse {
    success?: boolean;
    statusCode?: HttpStatusCode;
    message?: string | undefined;
    data?: WalletWithTransactionsDto;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}