//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError, AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export interface IClient {
    /**
     * @return OK
     */
    summary(): Promise<ObjectApiResponse>;
    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    pending(page: number | undefined, pageSize: number | undefined): Promise<WalletTransactionDtoIEnumerableApiResponse>;
    /**
     * @return OK
     */
    approve(transactionId: string): Promise<WalletTransactionDtoApiResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    reject(transactionId: string, body: string | undefined): Promise<WalletTransactionDtoApiResponse>;
    /**
     * @return OK
     */
    checkStatus(): Promise<ObjectApiResponse>;
    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    unverified(page: number | undefined, pageSize: number | undefined): Promise<BankAccountResponseDtoIEnumerableApiResponse>;
    /**
     * @return OK
     */
    verify(id: string): Promise<BankAccountResponseDtoApiResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    reject2(id: string, body: string | undefined): Promise<ObjectApiResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    confirm(id: string, body: PayoutConfirmationWithProofDto | undefined): Promise<CustomerPayoutResponseDtoApiResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    reject3(id: string, body: string | undefined): Promise<CustomerPayoutResponseDtoApiResponse>;
    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    pending2(page: number | undefined, pageSize: number | undefined): Promise<CustomerPayoutResponseDtoIEnumerableApiResponse>;
    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    pending3(page: number | undefined, pageSize: number | undefined): Promise<RefundResponseDtoIEnumerableApiResponse>;
    /**
     * @return OK
     */
    approve2(id: string): Promise<RefundResponseDtoApiResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    reject4(id: string, body: string | undefined): Promise<RefundResponseDtoApiResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    complete(id: string, body: string | undefined): Promise<RefundResponseDtoApiResponse>;
    /**
     * @return OK
     */
    bankGET(id: string): Promise<BankAccountResponseDto>;
    /**
     * @param body (optional) 
     * @return OK
     */
    bankPUT(id: string, body: BankAccountUpdateDto | undefined): Promise<BankAccountResponseDto>;
    /**
     * @return OK
     */
    sellerAll(sellerId: string): Promise<BankAccountResponseDto[]>;
    /**
     * @param body (optional) 
     * @return Created
     */
    bankPOST(body: BankAccountCreateDto | undefined): Promise<BankAccountResponseDto>;
    /**
     * @param id (optional) 
     * @return No Content
     */
    bankDELETE(id: string | undefined, sellerId: string): Promise<void>;
    /**
     * @param body (optional) 
     * @return OK
     */
    validate(body: BankAccountCreateDto | undefined): Promise<BankAccountValidationDto>;
    /**
     * @param body (optional) 
     * @return OK
     */
    validate2(body: PixValidationRequestDto | undefined): Promise<PixKeyValidationDtoApiResponse>;
    /**
     * @param body (optional) 
     * @return Created
     */
    payment(body: CustomerPayoutCreateDto | undefined): Promise<CustomerPayoutResponseDtoApiResponse>;
    /**
     * @return OK
     */
    customerPayouts(id: string): Promise<CustomerPayoutResponseDtoApiResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    dashboard(body: string[] | undefined): Promise<DashboardDataDto>;
    /**
     * @param body (optional) 
     * @return OK
     */
    historyAll(body: string[] | undefined): Promise<TransactionDataDto[]>;
    /**
     * @param body (optional) 
     * @return Created
     */
    depositsPOST(body: DepositRequestDto | undefined): Promise<DepositDtoApiResponse>;
    /**
     * @return OK
     */
    depositsGET(id: string): Promise<DepositDtoApiResponse>;
    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    seller(sellerId: string, page: number | undefined, pageSize: number | undefined): Promise<DepositDtoIEnumerableApiResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    callback(body: PaymentCallbackDto | undefined): Promise<void>;
    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    pending4(page: number | undefined, pageSize: number | undefined): Promise<CustomerPayoutResponseDtoIEnumerableApiResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    confirm2(payoutId: string, body: PayoutConfirmationDto | undefined): Promise<CustomerPayoutResponseDtoApiResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    reject5(payoutId: string, body: PayoutRejectionDto | undefined): Promise<CustomerPayoutResponseDtoApiResponse>;
    /**
     * @param body (optional) 
     * @return Created
     */
    refundPOST(body: RefundRequestDto | undefined): Promise<RefundResponseDtoApiResponse>;
    /**
     * @return OK
     */
    refundGET(id: string): Promise<RefundResponseDtoApiResponse>;
    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    seller2(sellerId: string, page: number | undefined, pageSize: number | undefined): Promise<RefundResponseDtoIEnumerableApiResponse>;
    /**
     * @return OK
     */
    walletsGET(id: string): Promise<WalletDtoApiResponse>;
    /**
     * @return OK
     */
    seller3(sellerId: string): Promise<WalletDtoIEnumerableApiResponse>;
    /**
     * @return OK
     */
    type(sellerId: string, walletType: WalletType): Promise<WalletDtoApiResponse>;
    /**
     * @param count (optional) 
     * @return OK
     */
    withTransactions(id: string, count: number | undefined): Promise<WalletWithTransactionsDtoApiResponse>;
    /**
     * @param body (optional) 
     * @return Created
     */
    walletsPOST(body: WalletCreateDto | undefined): Promise<WalletDtoApiResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    balancePUT(id: string, body: WalletUpdateDto | undefined): Promise<WalletDtoApiResponse>;
    /**
     * @return OK
     */
    balanceGET(id: string): Promise<DecimalApiResponse>;
    /**
     * @param sellerId (optional) 
     * @return OK
     */
    default(id: string, sellerId: string | undefined): Promise<WalletDtoApiResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    depositsPOST2(id: string, body: FundsOperationRequest | undefined): Promise<WalletDtoApiResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    withdrawals(id: string, body: FundsOperationRequest | undefined): Promise<WalletDtoApiResponse>;
    /**
     * @param sourceWalletId (optional) 
     * @param destinationWalletId (optional) 
     * @param body (optional) 
     * @return OK
     */
    transfer(sourceWalletId: string | undefined, destinationWalletId: string | undefined, body: FundsOperationRequest | undefined): Promise<ObjectApiResponse>;
    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    transactions(id: string, startDate: Date | undefined, endDate: Date | undefined, page: number | undefined, pageSize: number | undefined): Promise<WalletTransactionDtoListApiResponse>;
    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    all(page: number | undefined, pageSize: number | undefined): Promise<WalletDtoIEnumerableApiResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    balancePUT2(id: string, body: WalletUpdateDto | undefined): Promise<WalletDtoApiResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    walletTransactionsPOST(body: CreateTransactionRequest | undefined): Promise<void>;
    /**
     * @return OK
     */
    walletTransactionsGET(transactionId: string): Promise<void>;
    /**
     * @return OK
     */
    balanceGET2(walletId: string): Promise<void>;
    /**
     * @param status (optional) 
     * @param type (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    history(walletId: string, startDate: Date, endDate: Date, status: TransactionStatus | undefined, type: TransactionType | undefined, page: number | undefined, pageSize: number | undefined): Promise<void>;
    /**
     * @param body (optional) 
     * @return OK
     */
    status(transactionId: string, body: UpdateTransactionStatusRequest | undefined): Promise<void>;
    /**
     * @param body (optional) 
     * @return Created
     */
    withdrawsPOST(body: WithdrawRequestDto | undefined): Promise<WithdrawDtoApiResponse>;
    /**
     * @return OK
     */
    withdrawsGET(id: string): Promise<WithdrawDtoApiResponse>;
    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    seller4(sellerId: string, page: number | undefined, pageSize: number | undefined): Promise<WithdrawDtoIEnumerableApiResponse>;
    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    pending5(page: number | undefined, pageSize: number | undefined): Promise<WithdrawDtoIEnumerableApiResponse>;
    /**
     * @return OK
     */
    approve3(id: string): Promise<WithdrawDtoApiResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    reject6(id: string, body: string | undefined): Promise<WithdrawDtoApiResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    process(id: string, body: string | undefined): Promise<WithdrawDtoApiResponse>;
}

export class Client implements IClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @return OK
     */
    summary( cancelToken?: CancelToken): Promise<ObjectApiResponse> {
        let url_ = this.baseUrl + "/api/admin/dashboard/summary";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSummary(_response);
        });
    }

    protected processSummary(response: AxiosResponse): Promise<ObjectApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ObjectApiResponse.fromJS(resultData200);
            return Promise.resolve<ObjectApiResponse>(result200);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectApiResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ObjectApiResponse>(null as any);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    pending(page: number | undefined, pageSize: number | undefined, cancelToken?: CancelToken): Promise<WalletTransactionDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/admin/transactions/pending?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPending(_response);
        });
    }

    protected processPending(response: AxiosResponse): Promise<WalletTransactionDtoIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = WalletTransactionDtoIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<WalletTransactionDtoIEnumerableApiResponse>(result200);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectApiResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WalletTransactionDtoIEnumerableApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    approve(transactionId: string, cancelToken?: CancelToken): Promise<WalletTransactionDtoApiResponse> {
        let url_ = this.baseUrl + "/api/admin/transactions/{transactionId}/approve";
        if (transactionId === undefined || transactionId === null)
            throw new Error("The parameter 'transactionId' must be defined.");
        url_ = url_.replace("{transactionId}", encodeURIComponent("" + transactionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processApprove(_response);
        });
    }

    protected processApprove(response: AxiosResponse): Promise<WalletTransactionDtoApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = WalletTransactionDtoApiResponse.fromJS(resultData200);
            return Promise.resolve<WalletTransactionDtoApiResponse>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectApiResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectApiResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WalletTransactionDtoApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    reject(transactionId: string, body: string | undefined, cancelToken?: CancelToken): Promise<WalletTransactionDtoApiResponse> {
        let url_ = this.baseUrl + "/api/admin/transactions/{transactionId}/reject";
        if (transactionId === undefined || transactionId === null)
            throw new Error("The parameter 'transactionId' must be defined.");
        url_ = url_.replace("{transactionId}", encodeURIComponent("" + transactionId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReject(_response);
        });
    }

    protected processReject(response: AxiosResponse): Promise<WalletTransactionDtoApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = WalletTransactionDtoApiResponse.fromJS(resultData200);
            return Promise.resolve<WalletTransactionDtoApiResponse>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectApiResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectApiResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WalletTransactionDtoApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    checkStatus( cancelToken?: CancelToken): Promise<ObjectApiResponse> {
        let url_ = this.baseUrl + "/api/admin/check-status";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCheckStatus(_response);
        });
    }

    protected processCheckStatus(response: AxiosResponse): Promise<ObjectApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ObjectApiResponse.fromJS(resultData200);
            return Promise.resolve<ObjectApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ObjectApiResponse>(null as any);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    unverified(page: number | undefined, pageSize: number | undefined, cancelToken?: CancelToken): Promise<BankAccountResponseDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/admin/bank-accounts/unverified?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUnverified(_response);
        });
    }

    protected processUnverified(response: AxiosResponse): Promise<BankAccountResponseDtoIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BankAccountResponseDtoIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<BankAccountResponseDtoIEnumerableApiResponse>(result200);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectApiResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BankAccountResponseDtoIEnumerableApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    verify(id: string, cancelToken?: CancelToken): Promise<BankAccountResponseDtoApiResponse> {
        let url_ = this.baseUrl + "/api/admin/bank-accounts/{id}/verify";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processVerify(_response);
        });
    }

    protected processVerify(response: AxiosResponse): Promise<BankAccountResponseDtoApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BankAccountResponseDtoApiResponse.fromJS(resultData200);
            return Promise.resolve<BankAccountResponseDtoApiResponse>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectApiResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectApiResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BankAccountResponseDtoApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    reject2(id: string, body: string | undefined, cancelToken?: CancelToken): Promise<ObjectApiResponse> {
        let url_ = this.baseUrl + "/api/admin/bank-accounts/{id}/reject";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReject2(_response);
        });
    }

    protected processReject2(response: AxiosResponse): Promise<ObjectApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ObjectApiResponse.fromJS(resultData200);
            return Promise.resolve<ObjectApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ObjectApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    confirm(id: string, body: PayoutConfirmationWithProofDto | undefined, cancelToken?: CancelToken): Promise<CustomerPayoutResponseDtoApiResponse> {
        let url_ = this.baseUrl + "/api/admin/admin/{id}/confirm";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processConfirm(_response);
        });
    }

    protected processConfirm(response: AxiosResponse): Promise<CustomerPayoutResponseDtoApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CustomerPayoutResponseDtoApiResponse.fromJS(resultData200);
            return Promise.resolve<CustomerPayoutResponseDtoApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomerPayoutResponseDtoApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    reject3(id: string, body: string | undefined, cancelToken?: CancelToken): Promise<CustomerPayoutResponseDtoApiResponse> {
        let url_ = this.baseUrl + "/api/admin/admin/{id}/reject";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReject3(_response);
        });
    }

    protected processReject3(response: AxiosResponse): Promise<CustomerPayoutResponseDtoApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CustomerPayoutResponseDtoApiResponse.fromJS(resultData200);
            return Promise.resolve<CustomerPayoutResponseDtoApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomerPayoutResponseDtoApiResponse>(null as any);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    pending2(page: number | undefined, pageSize: number | undefined, cancelToken?: CancelToken): Promise<CustomerPayoutResponseDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/admin/admin/pending?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPending2(_response);
        });
    }

    protected processPending2(response: AxiosResponse): Promise<CustomerPayoutResponseDtoIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CustomerPayoutResponseDtoIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<CustomerPayoutResponseDtoIEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomerPayoutResponseDtoIEnumerableApiResponse>(null as any);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    pending3(page: number | undefined, pageSize: number | undefined, cancelToken?: CancelToken): Promise<RefundResponseDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/admin/refunds/pending?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPending3(_response);
        });
    }

    protected processPending3(response: AxiosResponse): Promise<RefundResponseDtoIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RefundResponseDtoIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<RefundResponseDtoIEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RefundResponseDtoIEnumerableApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    approve2(id: string, cancelToken?: CancelToken): Promise<RefundResponseDtoApiResponse> {
        let url_ = this.baseUrl + "/api/admin/refund/{id}/approve";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processApprove2(_response);
        });
    }

    protected processApprove2(response: AxiosResponse): Promise<RefundResponseDtoApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RefundResponseDtoApiResponse.fromJS(resultData200);
            return Promise.resolve<RefundResponseDtoApiResponse>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectApiResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RefundResponseDtoApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    reject4(id: string, body: string | undefined, cancelToken?: CancelToken): Promise<RefundResponseDtoApiResponse> {
        let url_ = this.baseUrl + "/api/admin/refund/{id}/reject";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReject4(_response);
        });
    }

    protected processReject4(response: AxiosResponse): Promise<RefundResponseDtoApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RefundResponseDtoApiResponse.fromJS(resultData200);
            return Promise.resolve<RefundResponseDtoApiResponse>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectApiResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RefundResponseDtoApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    complete(id: string, body: string | undefined, cancelToken?: CancelToken): Promise<RefundResponseDtoApiResponse> {
        let url_ = this.baseUrl + "/api/admin/refund/{id}/complete";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processComplete(_response);
        });
    }

    protected processComplete(response: AxiosResponse): Promise<RefundResponseDtoApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RefundResponseDtoApiResponse.fromJS(resultData200);
            return Promise.resolve<RefundResponseDtoApiResponse>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectApiResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RefundResponseDtoApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    bankGET(id: string, cancelToken?: CancelToken): Promise<BankAccountResponseDto> {
        let url_ = this.baseUrl + "/api/bank/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBankGET(_response);
        });
    }

    protected processBankGET(response: AxiosResponse): Promise<BankAccountResponseDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BankAccountResponseDto.fromJS(resultData200);
            return Promise.resolve<BankAccountResponseDto>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401  = _responseText;
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BankAccountResponseDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    bankPUT(id: string, body: BankAccountUpdateDto | undefined, cancelToken?: CancelToken): Promise<BankAccountResponseDto> {
        let url_ = this.baseUrl + "/api/bank/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBankPUT(_response);
        });
    }

    protected processBankPUT(response: AxiosResponse): Promise<BankAccountResponseDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BankAccountResponseDto.fromJS(resultData200);
            return Promise.resolve<BankAccountResponseDto>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BankAccountResponseDto>(null as any);
    }

    /**
     * @return OK
     */
    sellerAll(sellerId: string, cancelToken?: CancelToken): Promise<BankAccountResponseDto[]> {
        let url_ = this.baseUrl + "/api/bank/seller/{sellerId}";
        if (sellerId === undefined || sellerId === null)
            throw new Error("The parameter 'sellerId' must be defined.");
        url_ = url_.replace("{sellerId}", encodeURIComponent("" + sellerId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSellerAll(_response);
        });
    }

    protected processSellerAll(response: AxiosResponse): Promise<BankAccountResponseDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BankAccountResponseDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<BankAccountResponseDto[]>(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403  = _responseText;
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BankAccountResponseDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    bankPOST(body: BankAccountCreateDto | undefined, cancelToken?: CancelToken): Promise<BankAccountResponseDto> {
        let url_ = this.baseUrl + "/api/bank";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBankPOST(_response);
        });
    }

    protected processBankPOST(response: AxiosResponse): Promise<BankAccountResponseDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = BankAccountResponseDto.fromJS(resultData201);
            return Promise.resolve<BankAccountResponseDto>(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409  = _responseText;
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BankAccountResponseDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return No Content
     */
    bankDELETE(id: string | undefined, sellerId: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/bank/{sellerId}?";
        if (sellerId === undefined || sellerId === null)
            throw new Error("The parameter 'sellerId' must be defined.");
        url_ = url_.replace("{sellerId}", encodeURIComponent("" + sellerId));
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBankDELETE(_response);
        });
    }

    protected processBankDELETE(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    validate(body: BankAccountCreateDto | undefined, cancelToken?: CancelToken): Promise<BankAccountValidationDto> {
        let url_ = this.baseUrl + "/api/bank/validate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processValidate(_response);
        });
    }

    protected processValidate(response: AxiosResponse): Promise<BankAccountValidationDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BankAccountValidationDto.fromJS(resultData200);
            return Promise.resolve<BankAccountValidationDto>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException("Internal Server Error", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BankAccountValidationDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    validate2(body: PixValidationRequestDto | undefined, cancelToken?: CancelToken): Promise<PixKeyValidationDtoApiResponse> {
        let url_ = this.baseUrl + "/api/customer-payouts/validate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processValidate2(_response);
        });
    }

    protected processValidate2(response: AxiosResponse): Promise<PixKeyValidationDtoApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PixKeyValidationDtoApiResponse.fromJS(resultData200);
            return Promise.resolve<PixKeyValidationDtoApiResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ObjectApiResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PixKeyValidationDtoApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    payment(body: CustomerPayoutCreateDto | undefined, cancelToken?: CancelToken): Promise<CustomerPayoutResponseDtoApiResponse> {
        let url_ = this.baseUrl + "/api/customer-payouts/payment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPayment(_response);
        });
    }

    protected processPayment(response: AxiosResponse): Promise<CustomerPayoutResponseDtoApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = CustomerPayoutResponseDtoApiResponse.fromJS(resultData201);
            return Promise.resolve<CustomerPayoutResponseDtoApiResponse>(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ObjectApiResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomerPayoutResponseDtoApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    customerPayouts(id: string, cancelToken?: CancelToken): Promise<CustomerPayoutResponseDtoApiResponse> {
        let url_ = this.baseUrl + "/api/customer-payouts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCustomerPayouts(_response);
        });
    }

    protected processCustomerPayouts(response: AxiosResponse): Promise<CustomerPayoutResponseDtoApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CustomerPayoutResponseDtoApiResponse.fromJS(resultData200);
            return Promise.resolve<CustomerPayoutResponseDtoApiResponse>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectApiResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomerPayoutResponseDtoApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    dashboard(body: string[] | undefined, cancelToken?: CancelToken): Promise<DashboardDataDto> {
        let url_ = this.baseUrl + "/api/dashboard";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDashboard(_response);
        });
    }

    protected processDashboard(response: AxiosResponse): Promise<DashboardDataDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DashboardDataDto.fromJS(resultData200);
            return Promise.resolve<DashboardDataDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DashboardDataDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    historyAll(body: string[] | undefined, cancelToken?: CancelToken): Promise<TransactionDataDto[]> {
        let url_ = this.baseUrl + "/api/history";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processHistoryAll(_response);
        });
    }

    protected processHistoryAll(response: AxiosResponse): Promise<TransactionDataDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TransactionDataDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<TransactionDataDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TransactionDataDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    depositsPOST(body: DepositRequestDto | undefined, cancelToken?: CancelToken): Promise<DepositDtoApiResponse> {
        let url_ = this.baseUrl + "/api/deposits";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDepositsPOST(_response);
        });
    }

    protected processDepositsPOST(response: AxiosResponse): Promise<DepositDtoApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = DepositDtoApiResponse.fromJS(resultData201);
            return Promise.resolve<DepositDtoApiResponse>(result201);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DepositDtoApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    depositsGET(id: string, cancelToken?: CancelToken): Promise<DepositDtoApiResponse> {
        let url_ = this.baseUrl + "/api/deposits/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDepositsGET(_response);
        });
    }

    protected processDepositsGET(response: AxiosResponse): Promise<DepositDtoApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DepositDtoApiResponse.fromJS(resultData200);
            return Promise.resolve<DepositDtoApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DepositDtoApiResponse>(null as any);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    seller(sellerId: string, page: number | undefined, pageSize: number | undefined, cancelToken?: CancelToken): Promise<DepositDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/deposits/seller/{sellerId}?";
        if (sellerId === undefined || sellerId === null)
            throw new Error("The parameter 'sellerId' must be defined.");
        url_ = url_.replace("{sellerId}", encodeURIComponent("" + sellerId));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSeller(_response);
        });
    }

    protected processSeller(response: AxiosResponse): Promise<DepositDtoIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DepositDtoIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<DepositDtoIEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DepositDtoIEnumerableApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    callback(body: PaymentCallbackDto | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/deposits/callback";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCallback(_response);
        });
    }

    protected processCallback(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    pending4(page: number | undefined, pageSize: number | undefined, cancelToken?: CancelToken): Promise<CustomerPayoutResponseDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/admin/pix/pending?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPending4(_response);
        });
    }

    protected processPending4(response: AxiosResponse): Promise<CustomerPayoutResponseDtoIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CustomerPayoutResponseDtoIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<CustomerPayoutResponseDtoIEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomerPayoutResponseDtoIEnumerableApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    confirm2(payoutId: string, body: PayoutConfirmationDto | undefined, cancelToken?: CancelToken): Promise<CustomerPayoutResponseDtoApiResponse> {
        let url_ = this.baseUrl + "/api/admin/pix/{payoutId}/confirm";
        if (payoutId === undefined || payoutId === null)
            throw new Error("The parameter 'payoutId' must be defined.");
        url_ = url_.replace("{payoutId}", encodeURIComponent("" + payoutId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processConfirm2(_response);
        });
    }

    protected processConfirm2(response: AxiosResponse): Promise<CustomerPayoutResponseDtoApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CustomerPayoutResponseDtoApiResponse.fromJS(resultData200);
            return Promise.resolve<CustomerPayoutResponseDtoApiResponse>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectApiResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomerPayoutResponseDtoApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    reject5(payoutId: string, body: PayoutRejectionDto | undefined, cancelToken?: CancelToken): Promise<CustomerPayoutResponseDtoApiResponse> {
        let url_ = this.baseUrl + "/api/admin/pix/{payoutId}/reject";
        if (payoutId === undefined || payoutId === null)
            throw new Error("The parameter 'payoutId' must be defined.");
        url_ = url_.replace("{payoutId}", encodeURIComponent("" + payoutId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReject5(_response);
        });
    }

    protected processReject5(response: AxiosResponse): Promise<CustomerPayoutResponseDtoApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CustomerPayoutResponseDtoApiResponse.fromJS(resultData200);
            return Promise.resolve<CustomerPayoutResponseDtoApiResponse>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectApiResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomerPayoutResponseDtoApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    refundPOST(body: RefundRequestDto | undefined, cancelToken?: CancelToken): Promise<RefundResponseDtoApiResponse> {
        let url_ = this.baseUrl + "/api/refund";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRefundPOST(_response);
        });
    }

    protected processRefundPOST(response: AxiosResponse): Promise<RefundResponseDtoApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = RefundResponseDtoApiResponse.fromJS(resultData201);
            return Promise.resolve<RefundResponseDtoApiResponse>(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ObjectApiResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectApiResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RefundResponseDtoApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    refundGET(id: string, cancelToken?: CancelToken): Promise<RefundResponseDtoApiResponse> {
        let url_ = this.baseUrl + "/api/refund/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRefundGET(_response);
        });
    }

    protected processRefundGET(response: AxiosResponse): Promise<RefundResponseDtoApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RefundResponseDtoApiResponse.fromJS(resultData200);
            return Promise.resolve<RefundResponseDtoApiResponse>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectApiResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RefundResponseDtoApiResponse>(null as any);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    seller2(sellerId: string, page: number | undefined, pageSize: number | undefined, cancelToken?: CancelToken): Promise<RefundResponseDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/refund/seller/{sellerId}?";
        if (sellerId === undefined || sellerId === null)
            throw new Error("The parameter 'sellerId' must be defined.");
        url_ = url_.replace("{sellerId}", encodeURIComponent("" + sellerId));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSeller2(_response);
        });
    }

    protected processSeller2(response: AxiosResponse): Promise<RefundResponseDtoIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RefundResponseDtoIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<RefundResponseDtoIEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RefundResponseDtoIEnumerableApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    walletsGET(id: string, cancelToken?: CancelToken): Promise<WalletDtoApiResponse> {
        let url_ = this.baseUrl + "/api/wallets/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processWalletsGET(_response);
        });
    }

    protected processWalletsGET(response: AxiosResponse): Promise<WalletDtoApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = WalletDtoApiResponse.fromJS(resultData200);
            return Promise.resolve<WalletDtoApiResponse>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectApiResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectApiResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WalletDtoApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    seller3(sellerId: string, cancelToken?: CancelToken): Promise<WalletDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/wallets/seller/{sellerId}";
        if (sellerId === undefined || sellerId === null)
            throw new Error("The parameter 'sellerId' must be defined.");
        url_ = url_.replace("{sellerId}", encodeURIComponent("" + sellerId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSeller3(_response);
        });
    }

    protected processSeller3(response: AxiosResponse): Promise<WalletDtoIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = WalletDtoIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<WalletDtoIEnumerableApiResponse>(result200);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectApiResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WalletDtoIEnumerableApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    type(sellerId: string, walletType: WalletType, cancelToken?: CancelToken): Promise<WalletDtoApiResponse> {
        let url_ = this.baseUrl + "/api/wallets/seller/{sellerId}/type/{walletType}";
        if (sellerId === undefined || sellerId === null)
            throw new Error("The parameter 'sellerId' must be defined.");
        url_ = url_.replace("{sellerId}", encodeURIComponent("" + sellerId));
        if (walletType === undefined || walletType === null)
            throw new Error("The parameter 'walletType' must be defined.");
        url_ = url_.replace("{walletType}", encodeURIComponent("" + walletType));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processType(_response);
        });
    }

    protected processType(response: AxiosResponse): Promise<WalletDtoApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = WalletDtoApiResponse.fromJS(resultData200);
            return Promise.resolve<WalletDtoApiResponse>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectApiResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectApiResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WalletDtoApiResponse>(null as any);
    }

    /**
     * @param count (optional) 
     * @return OK
     */
    withTransactions(id: string, count: number | undefined, cancelToken?: CancelToken): Promise<WalletWithTransactionsDtoApiResponse> {
        let url_ = this.baseUrl + "/api/wallets/{id}/with-transactions?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processWithTransactions(_response);
        });
    }

    protected processWithTransactions(response: AxiosResponse): Promise<WalletWithTransactionsDtoApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = WalletWithTransactionsDtoApiResponse.fromJS(resultData200);
            return Promise.resolve<WalletWithTransactionsDtoApiResponse>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectApiResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectApiResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WalletWithTransactionsDtoApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    walletsPOST(body: WalletCreateDto | undefined, cancelToken?: CancelToken): Promise<WalletDtoApiResponse> {
        let url_ = this.baseUrl + "/api/wallets";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processWalletsPOST(_response);
        });
    }

    protected processWalletsPOST(response: AxiosResponse): Promise<WalletDtoApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = WalletDtoApiResponse.fromJS(resultData201);
            return Promise.resolve<WalletDtoApiResponse>(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ObjectApiResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409  = _responseText;
            result409 = ObjectApiResponse.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectApiResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WalletDtoApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    balancePUT(id: string, body: WalletUpdateDto | undefined, cancelToken?: CancelToken): Promise<WalletDtoApiResponse> {
        let url_ = this.baseUrl + "/api/wallets/{id}/balance";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBalancePUT(_response);
        });
    }

    protected processBalancePUT(response: AxiosResponse): Promise<WalletDtoApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = WalletDtoApiResponse.fromJS(resultData200);
            return Promise.resolve<WalletDtoApiResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ObjectApiResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectApiResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectApiResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WalletDtoApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    balanceGET(id: string, cancelToken?: CancelToken): Promise<DecimalApiResponse> {
        let url_ = this.baseUrl + "/api/wallets/{id}/balance";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBalanceGET(_response);
        });
    }

    protected processBalanceGET(response: AxiosResponse): Promise<DecimalApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DecimalApiResponse.fromJS(resultData200);
            return Promise.resolve<DecimalApiResponse>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectApiResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectApiResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DecimalApiResponse>(null as any);
    }

    /**
     * @param sellerId (optional) 
     * @return OK
     */
    default(id: string, sellerId: string | undefined, cancelToken?: CancelToken): Promise<WalletDtoApiResponse> {
        let url_ = this.baseUrl + "/api/wallets/{id}/default?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (sellerId === null)
            throw new Error("The parameter 'sellerId' cannot be null.");
        else if (sellerId !== undefined)
            url_ += "sellerId=" + encodeURIComponent("" + sellerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDefault(_response);
        });
    }

    protected processDefault(response: AxiosResponse): Promise<WalletDtoApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = WalletDtoApiResponse.fromJS(resultData200);
            return Promise.resolve<WalletDtoApiResponse>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectApiResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectApiResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WalletDtoApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    depositsPOST2(id: string, body: FundsOperationRequest | undefined, cancelToken?: CancelToken): Promise<WalletDtoApiResponse> {
        let url_ = this.baseUrl + "/api/wallets/{id}/deposits";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDepositsPOST2(_response);
        });
    }

    protected processDepositsPOST2(response: AxiosResponse): Promise<WalletDtoApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = WalletDtoApiResponse.fromJS(resultData200);
            return Promise.resolve<WalletDtoApiResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ObjectApiResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectApiResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectApiResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WalletDtoApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    withdrawals(id: string, body: FundsOperationRequest | undefined, cancelToken?: CancelToken): Promise<WalletDtoApiResponse> {
        let url_ = this.baseUrl + "/api/wallets/{id}/withdrawals";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processWithdrawals(_response);
        });
    }

    protected processWithdrawals(response: AxiosResponse): Promise<WalletDtoApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = WalletDtoApiResponse.fromJS(resultData200);
            return Promise.resolve<WalletDtoApiResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ObjectApiResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectApiResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectApiResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WalletDtoApiResponse>(null as any);
    }

    /**
     * @param sourceWalletId (optional) 
     * @param destinationWalletId (optional) 
     * @param body (optional) 
     * @return OK
     */
    transfer(sourceWalletId: string | undefined, destinationWalletId: string | undefined, body: FundsOperationRequest | undefined, cancelToken?: CancelToken): Promise<ObjectApiResponse> {
        let url_ = this.baseUrl + "/api/wallets/transfer?";
        if (sourceWalletId === null)
            throw new Error("The parameter 'sourceWalletId' cannot be null.");
        else if (sourceWalletId !== undefined)
            url_ += "sourceWalletId=" + encodeURIComponent("" + sourceWalletId) + "&";
        if (destinationWalletId === null)
            throw new Error("The parameter 'destinationWalletId' cannot be null.");
        else if (destinationWalletId !== undefined)
            url_ += "destinationWalletId=" + encodeURIComponent("" + destinationWalletId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTransfer(_response);
        });
    }

    protected processTransfer(response: AxiosResponse): Promise<ObjectApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ObjectApiResponse.fromJS(resultData200);
            return Promise.resolve<ObjectApiResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ObjectApiResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectApiResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectApiResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ObjectApiResponse>(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    transactions(id: string, startDate: Date | undefined, endDate: Date | undefined, page: number | undefined, pageSize: number | undefined, cancelToken?: CancelToken): Promise<WalletTransactionDtoListApiResponse> {
        let url_ = this.baseUrl + "/api/wallets/{id}/transactions?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTransactions(_response);
        });
    }

    protected processTransactions(response: AxiosResponse): Promise<WalletTransactionDtoListApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = WalletTransactionDtoListApiResponse.fromJS(resultData200);
            return Promise.resolve<WalletTransactionDtoListApiResponse>(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectApiResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectApiResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WalletTransactionDtoListApiResponse>(null as any);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    all(page: number | undefined, pageSize: number | undefined, cancelToken?: CancelToken): Promise<WalletDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/wallets/admin/all?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAll(_response);
        });
    }

    protected processAll(response: AxiosResponse): Promise<WalletDtoIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = WalletDtoIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<WalletDtoIEnumerableApiResponse>(result200);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectApiResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WalletDtoIEnumerableApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    balancePUT2(id: string, body: WalletUpdateDto | undefined, cancelToken?: CancelToken): Promise<WalletDtoApiResponse> {
        let url_ = this.baseUrl + "/api/wallets/admin/{id}/balance";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBalancePUT2(_response);
        });
    }

    protected processBalancePUT2(response: AxiosResponse): Promise<WalletDtoApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = WalletDtoApiResponse.fromJS(resultData200);
            return Promise.resolve<WalletDtoApiResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ObjectApiResponse.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ObjectApiResponse.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500  = _responseText;
            result500 = ObjectApiResponse.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WalletDtoApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    walletTransactionsPOST(body: CreateTransactionRequest | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/wallet-transactions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processWalletTransactionsPOST(_response);
        });
    }

    protected processWalletTransactionsPOST(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    walletTransactionsGET(transactionId: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/wallet-transactions/{transactionId}";
        if (transactionId === undefined || transactionId === null)
            throw new Error("The parameter 'transactionId' must be defined.");
        url_ = url_.replace("{transactionId}", encodeURIComponent("" + transactionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processWalletTransactionsGET(_response);
        });
    }

    protected processWalletTransactionsGET(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    balanceGET2(walletId: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/wallet-transactions/wallet/{walletId}/balance";
        if (walletId === undefined || walletId === null)
            throw new Error("The parameter 'walletId' must be defined.");
        url_ = url_.replace("{walletId}", encodeURIComponent("" + walletId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBalanceGET2(_response);
        });
    }

    protected processBalanceGET2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param status (optional) 
     * @param type (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    history(walletId: string, startDate: Date, endDate: Date, status: TransactionStatus | undefined, type: TransactionType | undefined, page: number | undefined, pageSize: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/wallet-transactions/wallet/{walletId}/history?";
        if (walletId === undefined || walletId === null)
            throw new Error("The parameter 'walletId' must be defined.");
        url_ = url_.replace("{walletId}", encodeURIComponent("" + walletId));
        if (startDate === undefined || startDate === null)
            throw new Error("The parameter 'startDate' must be defined and cannot be null.");
        else
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === undefined || endDate === null)
            throw new Error("The parameter 'endDate' must be defined and cannot be null.");
        else
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processHistory(_response);
        });
    }

    protected processHistory(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    status(transactionId: string, body: UpdateTransactionStatusRequest | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/wallet-transactions/{transactionId}/status";
        if (transactionId === undefined || transactionId === null)
            throw new Error("The parameter 'transactionId' must be defined.");
        url_ = url_.replace("{transactionId}", encodeURIComponent("" + transactionId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processStatus(_response);
        });
    }

    protected processStatus(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404  = _responseText;
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    withdrawsPOST(body: WithdrawRequestDto | undefined, cancelToken?: CancelToken): Promise<WithdrawDtoApiResponse> {
        let url_ = this.baseUrl + "/api/withdraws";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processWithdrawsPOST(_response);
        });
    }

    protected processWithdrawsPOST(response: AxiosResponse): Promise<WithdrawDtoApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = WithdrawDtoApiResponse.fromJS(resultData201);
            return Promise.resolve<WithdrawDtoApiResponse>(result201);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WithdrawDtoApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    withdrawsGET(id: string, cancelToken?: CancelToken): Promise<WithdrawDtoApiResponse> {
        let url_ = this.baseUrl + "/api/withdraws/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processWithdrawsGET(_response);
        });
    }

    protected processWithdrawsGET(response: AxiosResponse): Promise<WithdrawDtoApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = WithdrawDtoApiResponse.fromJS(resultData200);
            return Promise.resolve<WithdrawDtoApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WithdrawDtoApiResponse>(null as any);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    seller4(sellerId: string, page: number | undefined, pageSize: number | undefined, cancelToken?: CancelToken): Promise<WithdrawDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/withdraws/seller/{sellerId}?";
        if (sellerId === undefined || sellerId === null)
            throw new Error("The parameter 'sellerId' must be defined.");
        url_ = url_.replace("{sellerId}", encodeURIComponent("" + sellerId));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSeller4(_response);
        });
    }

    protected processSeller4(response: AxiosResponse): Promise<WithdrawDtoIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = WithdrawDtoIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<WithdrawDtoIEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WithdrawDtoIEnumerableApiResponse>(null as any);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @return OK
     */
    pending5(page: number | undefined, pageSize: number | undefined, cancelToken?: CancelToken): Promise<WithdrawDtoIEnumerableApiResponse> {
        let url_ = this.baseUrl + "/api/withdraws/pending?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPending5(_response);
        });
    }

    protected processPending5(response: AxiosResponse): Promise<WithdrawDtoIEnumerableApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = WithdrawDtoIEnumerableApiResponse.fromJS(resultData200);
            return Promise.resolve<WithdrawDtoIEnumerableApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WithdrawDtoIEnumerableApiResponse>(null as any);
    }

    /**
     * @return OK
     */
    approve3(id: string, cancelToken?: CancelToken): Promise<WithdrawDtoApiResponse> {
        let url_ = this.baseUrl + "/api/withdraws/{id}/approve";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processApprove3(_response);
        });
    }

    protected processApprove3(response: AxiosResponse): Promise<WithdrawDtoApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = WithdrawDtoApiResponse.fromJS(resultData200);
            return Promise.resolve<WithdrawDtoApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WithdrawDtoApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    reject6(id: string, body: string | undefined, cancelToken?: CancelToken): Promise<WithdrawDtoApiResponse> {
        let url_ = this.baseUrl + "/api/withdraws/{id}/reject";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReject6(_response);
        });
    }

    protected processReject6(response: AxiosResponse): Promise<WithdrawDtoApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = WithdrawDtoApiResponse.fromJS(resultData200);
            return Promise.resolve<WithdrawDtoApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WithdrawDtoApiResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    process(id: string, body: string | undefined, cancelToken?: CancelToken): Promise<WithdrawDtoApiResponse> {
        let url_ = this.baseUrl + "/api/withdraws/{id}/process";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processProcess(_response);
        });
    }

    protected processProcess(response: AxiosResponse): Promise<WithdrawDtoApiResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = WithdrawDtoApiResponse.fromJS(resultData200);
            return Promise.resolve<WithdrawDtoApiResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WithdrawDtoApiResponse>(null as any);
    }
}

export class BankAccountCreateDto implements IBankAccountCreateDto {
    sellerId?: string;
    bankName?: string | undefined;
    bankCode?: string | undefined;
    accountType?: BankAccountType;
    accountNumber?: string | undefined;
    branchNumber?: string | undefined;
    pixKey?: string | undefined;
    pixKeyType?: PixKeyType;
    documentNumber?: string | undefined;
    accountHolderName?: string | undefined;

    constructor(data?: IBankAccountCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sellerId = _data["sellerId"];
            this.bankName = _data["bankName"];
            this.bankCode = _data["bankCode"];
            this.accountType = _data["accountType"];
            this.accountNumber = _data["accountNumber"];
            this.branchNumber = _data["branchNumber"];
            this.pixKey = _data["pixKey"];
            this.pixKeyType = _data["pixKeyType"];
            this.documentNumber = _data["documentNumber"];
            this.accountHolderName = _data["accountHolderName"];
        }
    }

    static fromJS(data: any): BankAccountCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new BankAccountCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerId"] = this.sellerId;
        data["bankName"] = this.bankName;
        data["bankCode"] = this.bankCode;
        data["accountType"] = this.accountType;
        data["accountNumber"] = this.accountNumber;
        data["branchNumber"] = this.branchNumber;
        data["pixKey"] = this.pixKey;
        data["pixKeyType"] = this.pixKeyType;
        data["documentNumber"] = this.documentNumber;
        data["accountHolderName"] = this.accountHolderName;
        return data;
    }
}

export interface IBankAccountCreateDto {
    sellerId?: string;
    bankName?: string | undefined;
    bankCode?: string | undefined;
    accountType?: BankAccountType;
    accountNumber?: string | undefined;
    branchNumber?: string | undefined;
    pixKey?: string | undefined;
    pixKeyType?: PixKeyType;
    documentNumber?: string | undefined;
    accountHolderName?: string | undefined;
}

export class BankAccountDto implements IBankAccountDto {
    id?: string;
    bankName?: string | undefined;
    accountType?: string | undefined;
    accountNumber?: string | undefined;
    branchNumber?: string | undefined;
    pixKey?: string | undefined;
    pixKeyType?: string | undefined;
    accountHolderName?: string | undefined;

    constructor(data?: IBankAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.bankName = _data["bankName"];
            this.accountType = _data["accountType"];
            this.accountNumber = _data["accountNumber"];
            this.branchNumber = _data["branchNumber"];
            this.pixKey = _data["pixKey"];
            this.pixKeyType = _data["pixKeyType"];
            this.accountHolderName = _data["accountHolderName"];
        }
    }

    static fromJS(data: any): BankAccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new BankAccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["bankName"] = this.bankName;
        data["accountType"] = this.accountType;
        data["accountNumber"] = this.accountNumber;
        data["branchNumber"] = this.branchNumber;
        data["pixKey"] = this.pixKey;
        data["pixKeyType"] = this.pixKeyType;
        data["accountHolderName"] = this.accountHolderName;
        return data;
    }
}

export interface IBankAccountDto {
    id?: string;
    bankName?: string | undefined;
    accountType?: string | undefined;
    accountNumber?: string | undefined;
    branchNumber?: string | undefined;
    pixKey?: string | undefined;
    pixKeyType?: string | undefined;
    accountHolderName?: string | undefined;
}

export class BankAccountResponseDto implements IBankAccountResponseDto {
    id?: string;
    sellerId?: string;
    bankName?: string | undefined;
    bankCode?: string | undefined;
    accountType?: BankAccountType;
    accountNumber?: string | undefined;
    branchNumber?: string | undefined;
    pixKey?: string | undefined;
    pixKeyType?: PixKeyType;
    documentNumber?: string | undefined;
    accountHolderName?: string | undefined;
    isVerified?: boolean;
    status?: string | undefined;
    rejectionReason?: string | undefined;
    createdAt?: Date;
    lastUpdatedAt?: Date;

    constructor(data?: IBankAccountResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sellerId = _data["sellerId"];
            this.bankName = _data["bankName"];
            this.bankCode = _data["bankCode"];
            this.accountType = _data["accountType"];
            this.accountNumber = _data["accountNumber"];
            this.branchNumber = _data["branchNumber"];
            this.pixKey = _data["pixKey"];
            this.pixKeyType = _data["pixKeyType"];
            this.documentNumber = _data["documentNumber"];
            this.accountHolderName = _data["accountHolderName"];
            this.isVerified = _data["isVerified"];
            this.status = _data["status"];
            this.rejectionReason = _data["rejectionReason"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastUpdatedAt = _data["lastUpdatedAt"] ? new Date(_data["lastUpdatedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): BankAccountResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new BankAccountResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sellerId"] = this.sellerId;
        data["bankName"] = this.bankName;
        data["bankCode"] = this.bankCode;
        data["accountType"] = this.accountType;
        data["accountNumber"] = this.accountNumber;
        data["branchNumber"] = this.branchNumber;
        data["pixKey"] = this.pixKey;
        data["pixKeyType"] = this.pixKeyType;
        data["documentNumber"] = this.documentNumber;
        data["accountHolderName"] = this.accountHolderName;
        data["isVerified"] = this.isVerified;
        data["status"] = this.status;
        data["rejectionReason"] = this.rejectionReason;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastUpdatedAt"] = this.lastUpdatedAt ? this.lastUpdatedAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IBankAccountResponseDto {
    id?: string;
    sellerId?: string;
    bankName?: string | undefined;
    bankCode?: string | undefined;
    accountType?: BankAccountType;
    accountNumber?: string | undefined;
    branchNumber?: string | undefined;
    pixKey?: string | undefined;
    pixKeyType?: PixKeyType;
    documentNumber?: string | undefined;
    accountHolderName?: string | undefined;
    isVerified?: boolean;
    status?: string | undefined;
    rejectionReason?: string | undefined;
    createdAt?: Date;
    lastUpdatedAt?: Date;
}

export class BankAccountResponseDtoApiResponse implements IBankAccountResponseDtoApiResponse {
    success?: boolean;
    statusCode?: HttpStatusCode;
    message?: string | undefined;
    data?: BankAccountResponseDto;

    constructor(data?: IBankAccountResponseDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.statusCode = _data["statusCode"];
            this.message = _data["message"];
            this.data = _data["data"] ? BankAccountResponseDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BankAccountResponseDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BankAccountResponseDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["statusCode"] = this.statusCode;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IBankAccountResponseDtoApiResponse {
    success?: boolean;
    statusCode?: HttpStatusCode;
    message?: string | undefined;
    data?: BankAccountResponseDto;
}

export class BankAccountResponseDtoIEnumerableApiResponse implements IBankAccountResponseDtoIEnumerableApiResponse {
    success?: boolean;
    statusCode?: HttpStatusCode;
    message?: string | undefined;
    data?: BankAccountResponseDto[] | undefined;

    constructor(data?: IBankAccountResponseDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.statusCode = _data["statusCode"];
            this.message = _data["message"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(BankAccountResponseDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BankAccountResponseDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BankAccountResponseDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["statusCode"] = this.statusCode;
        data["message"] = this.message;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IBankAccountResponseDtoIEnumerableApiResponse {
    success?: boolean;
    statusCode?: HttpStatusCode;
    message?: string | undefined;
    data?: BankAccountResponseDto[] | undefined;
}

export enum BankAccountType {
    _0 = 0,
    _1 = 1,
}

export class BankAccountUpdateDto implements IBankAccountUpdateDto {
    bankName?: string | undefined;
    bankCode?: string | undefined;
    accountType?: BankAccountType;
    accountNumber?: string | undefined;
    branchNumber?: string | undefined;
    pixKey?: string | undefined;
    pixKeyType?: PixKeyType;
    documentNumber?: string | undefined;
    accountHolderName?: string | undefined;

    constructor(data?: IBankAccountUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bankName = _data["bankName"];
            this.bankCode = _data["bankCode"];
            this.accountType = _data["accountType"];
            this.accountNumber = _data["accountNumber"];
            this.branchNumber = _data["branchNumber"];
            this.pixKey = _data["pixKey"];
            this.pixKeyType = _data["pixKeyType"];
            this.documentNumber = _data["documentNumber"];
            this.accountHolderName = _data["accountHolderName"];
        }
    }

    static fromJS(data: any): BankAccountUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new BankAccountUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankName"] = this.bankName;
        data["bankCode"] = this.bankCode;
        data["accountType"] = this.accountType;
        data["accountNumber"] = this.accountNumber;
        data["branchNumber"] = this.branchNumber;
        data["pixKey"] = this.pixKey;
        data["pixKeyType"] = this.pixKeyType;
        data["documentNumber"] = this.documentNumber;
        data["accountHolderName"] = this.accountHolderName;
        return data;
    }
}

export interface IBankAccountUpdateDto {
    bankName?: string | undefined;
    bankCode?: string | undefined;
    accountType?: BankAccountType;
    accountNumber?: string | undefined;
    branchNumber?: string | undefined;
    pixKey?: string | undefined;
    pixKeyType?: PixKeyType;
    documentNumber?: string | undefined;
    accountHolderName?: string | undefined;
}

export class BankAccountValidationDto implements IBankAccountValidationDto {
    isValid?: boolean;
    validationErrors?: string[] | undefined;

    constructor(data?: IBankAccountValidationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isValid = _data["isValid"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
        }
    }

    static fromJS(data: any): BankAccountValidationDto {
        data = typeof data === 'object' ? data : {};
        let result = new BankAccountValidationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isValid"] = this.isValid;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        return data;
    }
}

export interface IBankAccountValidationDto {
    isValid?: boolean;
    validationErrors?: string[] | undefined;
}

export class BarChartDataDto implements IBarChartDataDto {
    day?: string | undefined;
    count?: number;

    constructor(data?: IBarChartDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.day = _data["day"];
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): BarChartDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new BarChartDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["day"] = this.day;
        data["count"] = this.count;
        return data;
    }
}

export interface IBarChartDataDto {
    day?: string | undefined;
    count?: number;
}

export class CreateTransactionRequest implements ICreateTransactionRequest {
    walletId!: string;
    amount!: number;
    type!: TransactionType;
    description!: string;
    reference?: string | undefined;

    constructor(data?: ICreateTransactionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.walletId = _data["walletId"];
            this.amount = _data["amount"];
            this.type = _data["type"];
            this.description = _data["description"];
            this.reference = _data["reference"];
        }
    }

    static fromJS(data: any): CreateTransactionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTransactionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["walletId"] = this.walletId;
        data["amount"] = this.amount;
        data["type"] = this.type;
        data["description"] = this.description;
        data["reference"] = this.reference;
        return data;
    }
}

export interface ICreateTransactionRequest {
    walletId: string;
    amount: number;
    type: TransactionType;
    description: string;
    reference?: string | undefined;
}

export class CustomerPayoutCreateDto implements ICustomerPayoutCreateDto {
    validationId!: string;
    amount!: number;
    description?: string | undefined;

    constructor(data?: ICustomerPayoutCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.validationId = _data["validationId"];
            this.amount = _data["amount"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CustomerPayoutCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerPayoutCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["validationId"] = this.validationId;
        data["amount"] = this.amount;
        data["description"] = this.description;
        return data;
    }
}

export interface ICustomerPayoutCreateDto {
    validationId: string;
    amount: number;
    description?: string | undefined;
}

export class CustomerPayoutResponseDto implements ICustomerPayoutResponseDto {
    id?: string;
    amount?: number;
    status?: string | undefined;
    requestedAt?: Date;
    processedAt?: Date | undefined;
    pixKey?: string | undefined;
    pixKeyType?: string | undefined;
    validationId?: string | undefined;
    paymentId?: string | undefined;

    constructor(data?: ICustomerPayoutResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.amount = _data["amount"];
            this.status = _data["status"];
            this.requestedAt = _data["requestedAt"] ? new Date(_data["requestedAt"].toString()) : <any>undefined;
            this.processedAt = _data["processedAt"] ? new Date(_data["processedAt"].toString()) : <any>undefined;
            this.pixKey = _data["pixKey"];
            this.pixKeyType = _data["pixKeyType"];
            this.validationId = _data["validationId"];
            this.paymentId = _data["paymentId"];
        }
    }

    static fromJS(data: any): CustomerPayoutResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerPayoutResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["amount"] = this.amount;
        data["status"] = this.status;
        data["requestedAt"] = this.requestedAt ? this.requestedAt.toISOString() : <any>undefined;
        data["processedAt"] = this.processedAt ? this.processedAt.toISOString() : <any>undefined;
        data["pixKey"] = this.pixKey;
        data["pixKeyType"] = this.pixKeyType;
        data["validationId"] = this.validationId;
        data["paymentId"] = this.paymentId;
        return data;
    }
}

export interface ICustomerPayoutResponseDto {
    id?: string;
    amount?: number;
    status?: string | undefined;
    requestedAt?: Date;
    processedAt?: Date | undefined;
    pixKey?: string | undefined;
    pixKeyType?: string | undefined;
    validationId?: string | undefined;
    paymentId?: string | undefined;
}

export class CustomerPayoutResponseDtoApiResponse implements ICustomerPayoutResponseDtoApiResponse {
    success?: boolean;
    statusCode?: HttpStatusCode;
    message?: string | undefined;
    data?: CustomerPayoutResponseDto;

    constructor(data?: ICustomerPayoutResponseDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.statusCode = _data["statusCode"];
            this.message = _data["message"];
            this.data = _data["data"] ? CustomerPayoutResponseDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CustomerPayoutResponseDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerPayoutResponseDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["statusCode"] = this.statusCode;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICustomerPayoutResponseDtoApiResponse {
    success?: boolean;
    statusCode?: HttpStatusCode;
    message?: string | undefined;
    data?: CustomerPayoutResponseDto;
}

export class CustomerPayoutResponseDtoIEnumerableApiResponse implements ICustomerPayoutResponseDtoIEnumerableApiResponse {
    success?: boolean;
    statusCode?: HttpStatusCode;
    message?: string | undefined;
    data?: CustomerPayoutResponseDto[] | undefined;

    constructor(data?: ICustomerPayoutResponseDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.statusCode = _data["statusCode"];
            this.message = _data["message"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(CustomerPayoutResponseDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CustomerPayoutResponseDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerPayoutResponseDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["statusCode"] = this.statusCode;
        data["message"] = this.message;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICustomerPayoutResponseDtoIEnumerableApiResponse {
    success?: boolean;
    statusCode?: HttpStatusCode;
    message?: string | undefined;
    data?: CustomerPayoutResponseDto[] | undefined;
}

export class DashboardDataDto implements IDashboardDataDto {
    barChartData?: BarChartDataDto[] | undefined;
    pieChartData?: PieChartDataDto[] | undefined;
    lineChartDotsData?: LineChartDataDto[] | undefined;
    lineChartData?: LineChartDataDto[] | undefined;
    overviewData?: OverviewDataDto;

    constructor(data?: IDashboardDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["barChartData"])) {
                this.barChartData = [] as any;
                for (let item of _data["barChartData"])
                    this.barChartData!.push(BarChartDataDto.fromJS(item));
            }
            if (Array.isArray(_data["pieChartData"])) {
                this.pieChartData = [] as any;
                for (let item of _data["pieChartData"])
                    this.pieChartData!.push(PieChartDataDto.fromJS(item));
            }
            if (Array.isArray(_data["lineChartDotsData"])) {
                this.lineChartDotsData = [] as any;
                for (let item of _data["lineChartDotsData"])
                    this.lineChartDotsData!.push(LineChartDataDto.fromJS(item));
            }
            if (Array.isArray(_data["lineChartData"])) {
                this.lineChartData = [] as any;
                for (let item of _data["lineChartData"])
                    this.lineChartData!.push(LineChartDataDto.fromJS(item));
            }
            this.overviewData = _data["overviewData"] ? OverviewDataDto.fromJS(_data["overviewData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DashboardDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.barChartData)) {
            data["barChartData"] = [];
            for (let item of this.barChartData)
                data["barChartData"].push(item.toJSON());
        }
        if (Array.isArray(this.pieChartData)) {
            data["pieChartData"] = [];
            for (let item of this.pieChartData)
                data["pieChartData"].push(item.toJSON());
        }
        if (Array.isArray(this.lineChartDotsData)) {
            data["lineChartDotsData"] = [];
            for (let item of this.lineChartDotsData)
                data["lineChartDotsData"].push(item.toJSON());
        }
        if (Array.isArray(this.lineChartData)) {
            data["lineChartData"] = [];
            for (let item of this.lineChartData)
                data["lineChartData"].push(item.toJSON());
        }
        data["overviewData"] = this.overviewData ? this.overviewData.toJSON() : <any>undefined;
        return data;
    }
}

export interface IDashboardDataDto {
    barChartData?: BarChartDataDto[] | undefined;
    pieChartData?: PieChartDataDto[] | undefined;
    lineChartDotsData?: LineChartDataDto[] | undefined;
    lineChartData?: LineChartDataDto[] | undefined;
    overviewData?: OverviewDataDto;
}

export class DecimalApiResponse implements IDecimalApiResponse {
    success?: boolean;
    statusCode?: HttpStatusCode;
    message?: string | undefined;
    data?: number;

    constructor(data?: IDecimalApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.statusCode = _data["statusCode"];
            this.message = _data["message"];
            this.data = _data["data"];
        }
    }

    static fromJS(data: any): DecimalApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DecimalApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["statusCode"] = this.statusCode;
        data["message"] = this.message;
        data["data"] = this.data;
        return data;
    }
}

export interface IDecimalApiResponse {
    success?: boolean;
    statusCode?: HttpStatusCode;
    message?: string | undefined;
    data?: number;
}

export class DepositDto implements IDepositDto {
    id?: string;
    sellerId?: string;
    walletId?: string;
    amount?: number;
    status?: string | undefined;
    createdAt?: Date;
    expiresAt?: Date;
    processedAt?: Date | undefined;
    transactionId?: string | undefined;
    qrCode?: string | undefined;
    paymentMethod?: string | undefined;

    constructor(data?: IDepositDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sellerId = _data["sellerId"];
            this.walletId = _data["walletId"];
            this.amount = _data["amount"];
            this.status = _data["status"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.expiresAt = _data["expiresAt"] ? new Date(_data["expiresAt"].toString()) : <any>undefined;
            this.processedAt = _data["processedAt"] ? new Date(_data["processedAt"].toString()) : <any>undefined;
            this.transactionId = _data["transactionId"];
            this.qrCode = _data["qrCode"];
            this.paymentMethod = _data["paymentMethod"];
        }
    }

    static fromJS(data: any): DepositDto {
        data = typeof data === 'object' ? data : {};
        let result = new DepositDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sellerId"] = this.sellerId;
        data["walletId"] = this.walletId;
        data["amount"] = this.amount;
        data["status"] = this.status;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["expiresAt"] = this.expiresAt ? this.expiresAt.toISOString() : <any>undefined;
        data["processedAt"] = this.processedAt ? this.processedAt.toISOString() : <any>undefined;
        data["transactionId"] = this.transactionId;
        data["qrCode"] = this.qrCode;
        data["paymentMethod"] = this.paymentMethod;
        return data;
    }
}

export interface IDepositDto {
    id?: string;
    sellerId?: string;
    walletId?: string;
    amount?: number;
    status?: string | undefined;
    createdAt?: Date;
    expiresAt?: Date;
    processedAt?: Date | undefined;
    transactionId?: string | undefined;
    qrCode?: string | undefined;
    paymentMethod?: string | undefined;
}

export class DepositDtoApiResponse implements IDepositDtoApiResponse {
    success?: boolean;
    statusCode?: HttpStatusCode;
    message?: string | undefined;
    data?: DepositDto;

    constructor(data?: IDepositDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.statusCode = _data["statusCode"];
            this.message = _data["message"];
            this.data = _data["data"] ? DepositDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DepositDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DepositDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["statusCode"] = this.statusCode;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IDepositDtoApiResponse {
    success?: boolean;
    statusCode?: HttpStatusCode;
    message?: string | undefined;
    data?: DepositDto;
}

export class DepositDtoIEnumerableApiResponse implements IDepositDtoIEnumerableApiResponse {
    success?: boolean;
    statusCode?: HttpStatusCode;
    message?: string | undefined;
    data?: DepositDto[] | undefined;

    constructor(data?: IDepositDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.statusCode = _data["statusCode"];
            this.message = _data["message"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(DepositDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DepositDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DepositDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["statusCode"] = this.statusCode;
        data["message"] = this.message;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDepositDtoIEnumerableApiResponse {
    success?: boolean;
    statusCode?: HttpStatusCode;
    message?: string | undefined;
    data?: DepositDto[] | undefined;
}

export class DepositRequestDto implements IDepositRequestDto {
    sellerId!: string;
    walletId!: string;
    amount!: number;
    sellerName!: string;
    sellerEmail!: string;
    sellerDocument!: string;
    sellerDocumentType!: string;

    constructor(data?: IDepositRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sellerId = _data["sellerId"];
            this.walletId = _data["walletId"];
            this.amount = _data["amount"];
            this.sellerName = _data["sellerName"];
            this.sellerEmail = _data["sellerEmail"];
            this.sellerDocument = _data["sellerDocument"];
            this.sellerDocumentType = _data["sellerDocumentType"];
        }
    }

    static fromJS(data: any): DepositRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new DepositRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerId"] = this.sellerId;
        data["walletId"] = this.walletId;
        data["amount"] = this.amount;
        data["sellerName"] = this.sellerName;
        data["sellerEmail"] = this.sellerEmail;
        data["sellerDocument"] = this.sellerDocument;
        data["sellerDocumentType"] = this.sellerDocumentType;
        return data;
    }
}

export interface IDepositRequestDto {
    sellerId: string;
    walletId: string;
    amount: number;
    sellerName: string;
    sellerEmail: string;
    sellerDocument: string;
    sellerDocumentType: string;
}

export class FundsOperationRequest implements IFundsOperationRequest {
    amount!: number;
    description?: string | undefined;
    reference?: string | undefined;

    constructor(data?: IFundsOperationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.amount = _data["amount"];
            this.description = _data["description"];
            this.reference = _data["reference"];
        }
    }

    static fromJS(data: any): FundsOperationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new FundsOperationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["description"] = this.description;
        data["reference"] = this.reference;
        return data;
    }
}

export interface IFundsOperationRequest {
    amount: number;
    description?: string | undefined;
    reference?: string | undefined;
}

export enum HttpStatusCode {
    _100 = 100,
    _101 = 101,
    _102 = 102,
    _103 = 103,
    _200 = 200,
    _201 = 201,
    _202 = 202,
    _203 = 203,
    _204 = 204,
    _205 = 205,
    _206 = 206,
    _207 = 207,
    _208 = 208,
    _226 = 226,
    _300 = 300,
    _301 = 301,
    _302 = 302,
    _303 = 303,
    _304 = 304,
    _305 = 305,
    _306 = 306,
    _307 = 307,
    _308 = 308,
    _400 = 400,
    _401 = 401,
    _402 = 402,
    _403 = 403,
    _404 = 404,
    _405 = 405,
    _406 = 406,
    _407 = 407,
    _408 = 408,
    _409 = 409,
    _410 = 410,
    _411 = 411,
    _412 = 412,
    _413 = 413,
    _414 = 414,
    _415 = 415,
    _416 = 416,
    _417 = 417,
    _421 = 421,
    _422 = 422,
    _423 = 423,
    _424 = 424,
    _426 = 426,
    _428 = 428,
    _429 = 429,
    _431 = 431,
    _451 = 451,
    _500 = 500,
    _501 = 501,
    _502 = 502,
    _503 = 503,
    _504 = 504,
    _505 = 505,
    _506 = 506,
    _507 = 507,
    _508 = 508,
    _510 = 510,
    _511 = 511,
}

export class LineChartDataDto implements ILineChartDataDto {
    date?: string | undefined;
    hour?: string | undefined;
    pix?: number;
    credit?: number;
    bankSlip?: number;
    totalAmount?: number;

    constructor(data?: ILineChartDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"];
            this.hour = _data["hour"];
            this.pix = _data["pix"];
            this.credit = _data["credit"];
            this.bankSlip = _data["bankSlip"];
            this.totalAmount = _data["totalAmount"];
        }
    }

    static fromJS(data: any): LineChartDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new LineChartDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date;
        data["hour"] = this.hour;
        data["pix"] = this.pix;
        data["credit"] = this.credit;
        data["bankSlip"] = this.bankSlip;
        data["totalAmount"] = this.totalAmount;
        return data;
    }
}

export interface ILineChartDataDto {
    date?: string | undefined;
    hour?: string | undefined;
    pix?: number;
    credit?: number;
    bankSlip?: number;
    totalAmount?: number;
}

export class ObjectApiResponse implements IObjectApiResponse {
    success?: boolean;
    statusCode?: HttpStatusCode;
    message?: string | undefined;
    data?: any | undefined;

    constructor(data?: IObjectApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.statusCode = _data["statusCode"];
            this.message = _data["message"];
            this.data = _data["data"];
        }
    }

    static fromJS(data: any): ObjectApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["statusCode"] = this.statusCode;
        data["message"] = this.message;
        data["data"] = this.data;
        return data;
    }
}

export interface IObjectApiResponse {
    success?: boolean;
    statusCode?: HttpStatusCode;
    message?: string | undefined;
    data?: any | undefined;
}

export class OverviewDataDto implements IOverviewDataDto {
    approvedAmount?: number;
    approvedCount?: number;
    rejectedAmount?: number;
    rejectedCount?: number;
    cancelledAmount?: number;
    cancelledCount?: number;
    pendingAmount?: number;
    pendingCount?: number;

    constructor(data?: IOverviewDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.approvedAmount = _data["approvedAmount"];
            this.approvedCount = _data["approvedCount"];
            this.rejectedAmount = _data["rejectedAmount"];
            this.rejectedCount = _data["rejectedCount"];
            this.cancelledAmount = _data["cancelledAmount"];
            this.cancelledCount = _data["cancelledCount"];
            this.pendingAmount = _data["pendingAmount"];
            this.pendingCount = _data["pendingCount"];
        }
    }

    static fromJS(data: any): OverviewDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new OverviewDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["approvedAmount"] = this.approvedAmount;
        data["approvedCount"] = this.approvedCount;
        data["rejectedAmount"] = this.rejectedAmount;
        data["rejectedCount"] = this.rejectedCount;
        data["cancelledAmount"] = this.cancelledAmount;
        data["cancelledCount"] = this.cancelledCount;
        data["pendingAmount"] = this.pendingAmount;
        data["pendingCount"] = this.pendingCount;
        return data;
    }
}

export interface IOverviewDataDto {
    approvedAmount?: number;
    approvedCount?: number;
    rejectedAmount?: number;
    rejectedCount?: number;
    cancelledAmount?: number;
    cancelledCount?: number;
    pendingAmount?: number;
    pendingCount?: number;
}

export class PaymentCallbackDto implements IPaymentCallbackDto {
    transactionId!: string;
    status!: string;
    amount!: number;

    constructor(data?: IPaymentCallbackDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transactionId = _data["transactionId"];
            this.status = _data["status"];
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): PaymentCallbackDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentCallbackDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionId"] = this.transactionId;
        data["status"] = this.status;
        data["amount"] = this.amount;
        return data;
    }
}

export interface IPaymentCallbackDto {
    transactionId: string;
    status: string;
    amount: number;
}

export class PayoutConfirmationDto implements IPayoutConfirmationDto {
    paymentProofId!: string;

    constructor(data?: IPayoutConfirmationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentProofId = _data["paymentProofId"];
        }
    }

    static fromJS(data: any): PayoutConfirmationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PayoutConfirmationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentProofId"] = this.paymentProofId;
        return data;
    }
}

export interface IPayoutConfirmationDto {
    paymentProofId: string;
}

export class PayoutConfirmationWithProofDto implements IPayoutConfirmationWithProofDto {
    value!: number;
    proofReference!: string;
    notes?: string | undefined;

    constructor(data?: IPayoutConfirmationWithProofDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.proofReference = _data["proofReference"];
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): PayoutConfirmationWithProofDto {
        data = typeof data === 'object' ? data : {};
        let result = new PayoutConfirmationWithProofDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["proofReference"] = this.proofReference;
        data["notes"] = this.notes;
        return data;
    }
}

export interface IPayoutConfirmationWithProofDto {
    value: number;
    proofReference: string;
    notes?: string | undefined;
}

export class PayoutRejectionDto implements IPayoutRejectionDto {
    rejectionReason!: string;

    constructor(data?: IPayoutRejectionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rejectionReason = _data["rejectionReason"];
        }
    }

    static fromJS(data: any): PayoutRejectionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PayoutRejectionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rejectionReason"] = this.rejectionReason;
        return data;
    }
}

export interface IPayoutRejectionDto {
    rejectionReason: string;
}

export class PieChartDataDto implements IPieChartDataDto {
    paymentType?: string | undefined;
    count?: number;

    constructor(data?: IPieChartDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentType = _data["paymentType"];
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): PieChartDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new PieChartDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentType"] = this.paymentType;
        data["count"] = this.count;
        return data;
    }
}

export interface IPieChartDataDto {
    paymentType?: string | undefined;
    count?: number;
}

export enum PixKeyType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class PixKeyValidationDto implements IPixKeyValidationDto {
    isValid?: boolean;
    pixKey?: string | undefined;
    pixKeyType?: string | undefined;
    validationId?: string | undefined;
    errorMessage?: string | undefined;
    validatedAt?: Date;

    constructor(data?: IPixKeyValidationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isValid = _data["isValid"];
            this.pixKey = _data["pixKey"];
            this.pixKeyType = _data["pixKeyType"];
            this.validationId = _data["validationId"];
            this.errorMessage = _data["errorMessage"];
            this.validatedAt = _data["validatedAt"] ? new Date(_data["validatedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PixKeyValidationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PixKeyValidationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isValid"] = this.isValid;
        data["pixKey"] = this.pixKey;
        data["pixKeyType"] = this.pixKeyType;
        data["validationId"] = this.validationId;
        data["errorMessage"] = this.errorMessage;
        data["validatedAt"] = this.validatedAt ? this.validatedAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IPixKeyValidationDto {
    isValid?: boolean;
    pixKey?: string | undefined;
    pixKeyType?: string | undefined;
    validationId?: string | undefined;
    errorMessage?: string | undefined;
    validatedAt?: Date;
}

export class PixKeyValidationDtoApiResponse implements IPixKeyValidationDtoApiResponse {
    success?: boolean;
    statusCode?: HttpStatusCode;
    message?: string | undefined;
    data?: PixKeyValidationDto;

    constructor(data?: IPixKeyValidationDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.statusCode = _data["statusCode"];
            this.message = _data["message"];
            this.data = _data["data"] ? PixKeyValidationDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PixKeyValidationDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PixKeyValidationDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["statusCode"] = this.statusCode;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPixKeyValidationDtoApiResponse {
    success?: boolean;
    statusCode?: HttpStatusCode;
    message?: string | undefined;
    data?: PixKeyValidationDto;
}

export class PixValidationRequestDto implements IPixValidationRequestDto {
    pixKey!: string;
    pixKeyType!: string;

    constructor(data?: IPixValidationRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pixKey = _data["pixKey"];
            this.pixKeyType = _data["pixKeyType"];
        }
    }

    static fromJS(data: any): PixValidationRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new PixValidationRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pixKey"] = this.pixKey;
        data["pixKeyType"] = this.pixKeyType;
        return data;
    }
}

export interface IPixValidationRequestDto {
    pixKey: string;
    pixKeyType: string;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export class RefundRequestDto implements IRefundRequestDto {
    transactionId!: string;
    amount!: number;
    reason!: string;
    externalReference?: string | undefined;

    constructor(data?: IRefundRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transactionId = _data["transactionId"];
            this.amount = _data["amount"];
            this.reason = _data["reason"];
            this.externalReference = _data["externalReference"];
        }
    }

    static fromJS(data: any): RefundRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new RefundRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionId"] = this.transactionId;
        data["amount"] = this.amount;
        data["reason"] = this.reason;
        data["externalReference"] = this.externalReference;
        return data;
    }
}

export interface IRefundRequestDto {
    transactionId: string;
    amount: number;
    reason: string;
    externalReference?: string | undefined;
}

export class RefundResponseDto implements IRefundResponseDto {
    id?: string;
    transactionId?: string;
    amount?: number;
    status?: string | undefined;
    reason?: string | undefined;
    externalReference?: string | undefined;
    createdAt?: Date;
    processedAt?: Date | undefined;
    failReason?: string | undefined;

    constructor(data?: IRefundResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.transactionId = _data["transactionId"];
            this.amount = _data["amount"];
            this.status = _data["status"];
            this.reason = _data["reason"];
            this.externalReference = _data["externalReference"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.processedAt = _data["processedAt"] ? new Date(_data["processedAt"].toString()) : <any>undefined;
            this.failReason = _data["failReason"];
        }
    }

    static fromJS(data: any): RefundResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new RefundResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["transactionId"] = this.transactionId;
        data["amount"] = this.amount;
        data["status"] = this.status;
        data["reason"] = this.reason;
        data["externalReference"] = this.externalReference;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["processedAt"] = this.processedAt ? this.processedAt.toISOString() : <any>undefined;
        data["failReason"] = this.failReason;
        return data;
    }
}

export interface IRefundResponseDto {
    id?: string;
    transactionId?: string;
    amount?: number;
    status?: string | undefined;
    reason?: string | undefined;
    externalReference?: string | undefined;
    createdAt?: Date;
    processedAt?: Date | undefined;
    failReason?: string | undefined;
}

export class RefundResponseDtoApiResponse implements IRefundResponseDtoApiResponse {
    success?: boolean;
    statusCode?: HttpStatusCode;
    message?: string | undefined;
    data?: RefundResponseDto;

    constructor(data?: IRefundResponseDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.statusCode = _data["statusCode"];
            this.message = _data["message"];
            this.data = _data["data"] ? RefundResponseDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RefundResponseDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RefundResponseDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["statusCode"] = this.statusCode;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IRefundResponseDtoApiResponse {
    success?: boolean;
    statusCode?: HttpStatusCode;
    message?: string | undefined;
    data?: RefundResponseDto;
}

export class RefundResponseDtoIEnumerableApiResponse implements IRefundResponseDtoIEnumerableApiResponse {
    success?: boolean;
    statusCode?: HttpStatusCode;
    message?: string | undefined;
    data?: RefundResponseDto[] | undefined;

    constructor(data?: IRefundResponseDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.statusCode = _data["statusCode"];
            this.message = _data["message"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(RefundResponseDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RefundResponseDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RefundResponseDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["statusCode"] = this.statusCode;
        data["message"] = this.message;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRefundResponseDtoIEnumerableApiResponse {
    success?: boolean;
    statusCode?: HttpStatusCode;
    message?: string | undefined;
    data?: RefundResponseDto[] | undefined;
}

export class TransactionDataDto implements ITransactionDataDto {
    id?: string;
    customer?: string | undefined;
    sellerId?: string;
    createdAt?: Date;
    paidAt?: Date | undefined;
    status?: string | undefined;
    amount?: number;
    paymentType?: string | undefined;
    description?: string | undefined;

    constructor(data?: ITransactionDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.customer = _data["customer"];
            this.sellerId = _data["sellerId"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.paidAt = _data["paidAt"] ? new Date(_data["paidAt"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.amount = _data["amount"];
            this.paymentType = _data["paymentType"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): TransactionDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["customer"] = this.customer;
        data["sellerId"] = this.sellerId;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["paidAt"] = this.paidAt ? this.paidAt.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["amount"] = this.amount;
        data["paymentType"] = this.paymentType;
        data["description"] = this.description;
        return data;
    }
}

export interface ITransactionDataDto {
    id?: string;
    customer?: string | undefined;
    sellerId?: string;
    createdAt?: Date;
    paidAt?: Date | undefined;
    status?: string | undefined;
    amount?: number;
    paymentType?: string | undefined;
    description?: string | undefined;
}

export enum TransactionStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export enum TransactionType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
}

export class UpdateTransactionStatusRequest implements IUpdateTransactionStatusRequest {
    status!: TransactionStatus;
    reason?: string | undefined;

    constructor(data?: IUpdateTransactionStatusRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.reason = _data["reason"];
        }
    }

    static fromJS(data: any): UpdateTransactionStatusRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTransactionStatusRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["reason"] = this.reason;
        return data;
    }
}

export interface IUpdateTransactionStatusRequest {
    status: TransactionStatus;
    reason?: string | undefined;
}

export class WalletCreateDto implements IWalletCreateDto {
    sellerId!: string;
    walletType!: WalletType;
    isDefault?: boolean;

    constructor(data?: IWalletCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sellerId = _data["sellerId"];
            this.walletType = _data["walletType"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): WalletCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new WalletCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerId"] = this.sellerId;
        data["walletType"] = this.walletType;
        data["isDefault"] = this.isDefault;
        return data;
    }
}

export interface IWalletCreateDto {
    sellerId: string;
    walletType: WalletType;
    isDefault?: boolean;
}

export class WalletDto implements IWalletDto {
    id?: string;
    sellerId?: string;
    availableBalance?: number;
    pendingBalance?: number;
    totalBalance?: number;
    walletType?: WalletType;
    isDefault?: boolean;
    lastUpdateAt?: Date;
    createdAt?: Date;

    constructor(data?: IWalletDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sellerId = _data["sellerId"];
            this.availableBalance = _data["availableBalance"];
            this.pendingBalance = _data["pendingBalance"];
            this.totalBalance = _data["totalBalance"];
            this.walletType = _data["walletType"];
            this.isDefault = _data["isDefault"];
            this.lastUpdateAt = _data["lastUpdateAt"] ? new Date(_data["lastUpdateAt"].toString()) : <any>undefined;
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): WalletDto {
        data = typeof data === 'object' ? data : {};
        let result = new WalletDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sellerId"] = this.sellerId;
        data["availableBalance"] = this.availableBalance;
        data["pendingBalance"] = this.pendingBalance;
        data["totalBalance"] = this.totalBalance;
        data["walletType"] = this.walletType;
        data["isDefault"] = this.isDefault;
        data["lastUpdateAt"] = this.lastUpdateAt ? this.lastUpdateAt.toISOString() : <any>undefined;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IWalletDto {
    id?: string;
    sellerId?: string;
    availableBalance?: number;
    pendingBalance?: number;
    totalBalance?: number;
    walletType?: WalletType;
    isDefault?: boolean;
    lastUpdateAt?: Date;
    createdAt?: Date;
}

export class WalletDtoApiResponse implements IWalletDtoApiResponse {
    success?: boolean;
    statusCode?: HttpStatusCode;
    message?: string | undefined;
    data?: WalletDto;

    constructor(data?: IWalletDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.statusCode = _data["statusCode"];
            this.message = _data["message"];
            this.data = _data["data"] ? WalletDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): WalletDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new WalletDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["statusCode"] = this.statusCode;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IWalletDtoApiResponse {
    success?: boolean;
    statusCode?: HttpStatusCode;
    message?: string | undefined;
    data?: WalletDto;
}

export class WalletDtoIEnumerableApiResponse implements IWalletDtoIEnumerableApiResponse {
    success?: boolean;
    statusCode?: HttpStatusCode;
    message?: string | undefined;
    data?: WalletDto[] | undefined;

    constructor(data?: IWalletDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.statusCode = _data["statusCode"];
            this.message = _data["message"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(WalletDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WalletDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new WalletDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["statusCode"] = this.statusCode;
        data["message"] = this.message;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWalletDtoIEnumerableApiResponse {
    success?: boolean;
    statusCode?: HttpStatusCode;
    message?: string | undefined;
    data?: WalletDto[] | undefined;
}

export class WalletTransactionDto implements IWalletTransactionDto {
    id?: string;
    walletId?: string;
    amount?: number;
    type?: string | undefined;
    status?: string | undefined;
    description?: string | undefined;
    reference?: string | undefined;
    createdAt?: Date;
    processedAt?: Date | undefined;

    constructor(data?: IWalletTransactionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.walletId = _data["walletId"];
            this.amount = _data["amount"];
            this.type = _data["type"];
            this.status = _data["status"];
            this.description = _data["description"];
            this.reference = _data["reference"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.processedAt = _data["processedAt"] ? new Date(_data["processedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): WalletTransactionDto {
        data = typeof data === 'object' ? data : {};
        let result = new WalletTransactionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["walletId"] = this.walletId;
        data["amount"] = this.amount;
        data["type"] = this.type;
        data["status"] = this.status;
        data["description"] = this.description;
        data["reference"] = this.reference;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["processedAt"] = this.processedAt ? this.processedAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IWalletTransactionDto {
    id?: string;
    walletId?: string;
    amount?: number;
    type?: string | undefined;
    status?: string | undefined;
    description?: string | undefined;
    reference?: string | undefined;
    createdAt?: Date;
    processedAt?: Date | undefined;
}

export class WalletTransactionDtoApiResponse implements IWalletTransactionDtoApiResponse {
    success?: boolean;
    statusCode?: HttpStatusCode;
    message?: string | undefined;
    data?: WalletTransactionDto;

    constructor(data?: IWalletTransactionDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.statusCode = _data["statusCode"];
            this.message = _data["message"];
            this.data = _data["data"] ? WalletTransactionDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): WalletTransactionDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new WalletTransactionDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["statusCode"] = this.statusCode;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IWalletTransactionDtoApiResponse {
    success?: boolean;
    statusCode?: HttpStatusCode;
    message?: string | undefined;
    data?: WalletTransactionDto;
}

export class WalletTransactionDtoIEnumerableApiResponse implements IWalletTransactionDtoIEnumerableApiResponse {
    success?: boolean;
    statusCode?: HttpStatusCode;
    message?: string | undefined;
    data?: WalletTransactionDto[] | undefined;

    constructor(data?: IWalletTransactionDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.statusCode = _data["statusCode"];
            this.message = _data["message"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(WalletTransactionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WalletTransactionDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new WalletTransactionDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["statusCode"] = this.statusCode;
        data["message"] = this.message;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWalletTransactionDtoIEnumerableApiResponse {
    success?: boolean;
    statusCode?: HttpStatusCode;
    message?: string | undefined;
    data?: WalletTransactionDto[] | undefined;
}

export class WalletTransactionDtoListApiResponse implements IWalletTransactionDtoListApiResponse {
    success?: boolean;
    statusCode?: HttpStatusCode;
    message?: string | undefined;
    data?: WalletTransactionDto[] | undefined;

    constructor(data?: IWalletTransactionDtoListApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.statusCode = _data["statusCode"];
            this.message = _data["message"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(WalletTransactionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WalletTransactionDtoListApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new WalletTransactionDtoListApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["statusCode"] = this.statusCode;
        data["message"] = this.message;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWalletTransactionDtoListApiResponse {
    success?: boolean;
    statusCode?: HttpStatusCode;
    message?: string | undefined;
    data?: WalletTransactionDto[] | undefined;
}

export enum WalletType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class WalletUpdateDto implements IWalletUpdateDto {
    availableBalance!: number;
    pendingBalance!: number;

    constructor(data?: IWalletUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.availableBalance = _data["availableBalance"];
            this.pendingBalance = _data["pendingBalance"];
        }
    }

    static fromJS(data: any): WalletUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new WalletUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["availableBalance"] = this.availableBalance;
        data["pendingBalance"] = this.pendingBalance;
        return data;
    }
}

export interface IWalletUpdateDto {
    availableBalance: number;
    pendingBalance: number;
}

export class WalletWithTransactionsDto implements IWalletWithTransactionsDto {
    wallet?: WalletDto;
    recentTransactions?: WalletTransactionDto[] | undefined;

    constructor(data?: IWalletWithTransactionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wallet = _data["wallet"] ? WalletDto.fromJS(_data["wallet"]) : <any>undefined;
            if (Array.isArray(_data["recentTransactions"])) {
                this.recentTransactions = [] as any;
                for (let item of _data["recentTransactions"])
                    this.recentTransactions!.push(WalletTransactionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WalletWithTransactionsDto {
        data = typeof data === 'object' ? data : {};
        let result = new WalletWithTransactionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wallet"] = this.wallet ? this.wallet.toJSON() : <any>undefined;
        if (Array.isArray(this.recentTransactions)) {
            data["recentTransactions"] = [];
            for (let item of this.recentTransactions)
                data["recentTransactions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWalletWithTransactionsDto {
    wallet?: WalletDto;
    recentTransactions?: WalletTransactionDto[] | undefined;
}

export class WalletWithTransactionsDtoApiResponse implements IWalletWithTransactionsDtoApiResponse {
    success?: boolean;
    statusCode?: HttpStatusCode;
    message?: string | undefined;
    data?: WalletWithTransactionsDto;

    constructor(data?: IWalletWithTransactionsDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.statusCode = _data["statusCode"];
            this.message = _data["message"];
            this.data = _data["data"] ? WalletWithTransactionsDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): WalletWithTransactionsDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new WalletWithTransactionsDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["statusCode"] = this.statusCode;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IWalletWithTransactionsDtoApiResponse {
    success?: boolean;
    statusCode?: HttpStatusCode;
    message?: string | undefined;
    data?: WalletWithTransactionsDto;
}

export class WithdrawDto implements IWithdrawDto {
    id?: string;
    sellerId?: string;
    amount?: number;
    status?: string | undefined;
    withdrawMethod?: string | undefined;
    requestedAt?: Date;
    processedAt?: Date | undefined;
    bankAccountId?: string;
    bankAccount?: BankAccountDto;
    rejectionReason?: string | undefined;
    transactionReceipt?: string | undefined;
    approvedAt?: Date | undefined;

    constructor(data?: IWithdrawDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sellerId = _data["sellerId"];
            this.amount = _data["amount"];
            this.status = _data["status"];
            this.withdrawMethod = _data["withdrawMethod"];
            this.requestedAt = _data["requestedAt"] ? new Date(_data["requestedAt"].toString()) : <any>undefined;
            this.processedAt = _data["processedAt"] ? new Date(_data["processedAt"].toString()) : <any>undefined;
            this.bankAccountId = _data["bankAccountId"];
            this.bankAccount = _data["bankAccount"] ? BankAccountDto.fromJS(_data["bankAccount"]) : <any>undefined;
            this.rejectionReason = _data["rejectionReason"];
            this.transactionReceipt = _data["transactionReceipt"];
            this.approvedAt = _data["approvedAt"] ? new Date(_data["approvedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): WithdrawDto {
        data = typeof data === 'object' ? data : {};
        let result = new WithdrawDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sellerId"] = this.sellerId;
        data["amount"] = this.amount;
        data["status"] = this.status;
        data["withdrawMethod"] = this.withdrawMethod;
        data["requestedAt"] = this.requestedAt ? this.requestedAt.toISOString() : <any>undefined;
        data["processedAt"] = this.processedAt ? this.processedAt.toISOString() : <any>undefined;
        data["bankAccountId"] = this.bankAccountId;
        data["bankAccount"] = this.bankAccount ? this.bankAccount.toJSON() : <any>undefined;
        data["rejectionReason"] = this.rejectionReason;
        data["transactionReceipt"] = this.transactionReceipt;
        data["approvedAt"] = this.approvedAt ? this.approvedAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IWithdrawDto {
    id?: string;
    sellerId?: string;
    amount?: number;
    status?: string | undefined;
    withdrawMethod?: string | undefined;
    requestedAt?: Date;
    processedAt?: Date | undefined;
    bankAccountId?: string;
    bankAccount?: BankAccountDto;
    rejectionReason?: string | undefined;
    transactionReceipt?: string | undefined;
    approvedAt?: Date | undefined;
}

export class WithdrawDtoApiResponse implements IWithdrawDtoApiResponse {
    success?: boolean;
    statusCode?: HttpStatusCode;
    message?: string | undefined;
    data?: WithdrawDto;

    constructor(data?: IWithdrawDtoApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.statusCode = _data["statusCode"];
            this.message = _data["message"];
            this.data = _data["data"] ? WithdrawDto.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): WithdrawDtoApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new WithdrawDtoApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["statusCode"] = this.statusCode;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IWithdrawDtoApiResponse {
    success?: boolean;
    statusCode?: HttpStatusCode;
    message?: string | undefined;
    data?: WithdrawDto;
}

export class WithdrawDtoIEnumerableApiResponse implements IWithdrawDtoIEnumerableApiResponse {
    success?: boolean;
    statusCode?: HttpStatusCode;
    message?: string | undefined;
    data?: WithdrawDto[] | undefined;

    constructor(data?: IWithdrawDtoIEnumerableApiResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.statusCode = _data["statusCode"];
            this.message = _data["message"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(WithdrawDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WithdrawDtoIEnumerableApiResponse {
        data = typeof data === 'object' ? data : {};
        let result = new WithdrawDtoIEnumerableApiResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["statusCode"] = this.statusCode;
        data["message"] = this.message;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWithdrawDtoIEnumerableApiResponse {
    success?: boolean;
    statusCode?: HttpStatusCode;
    message?: string | undefined;
    data?: WithdrawDto[] | undefined;
}

export class WithdrawRequestDto implements IWithdrawRequestDto {
    sellerId!: string;
    walletId!: string;
    bankAccountId!: string;
    amount!: number;
    method!: string;

    constructor(data?: IWithdrawRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sellerId = _data["sellerId"];
            this.walletId = _data["walletId"];
            this.bankAccountId = _data["bankAccountId"];
            this.amount = _data["amount"];
            this.method = _data["method"];
        }
    }

    static fromJS(data: any): WithdrawRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new WithdrawRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerId"] = this.sellerId;
        data["walletId"] = this.walletId;
        data["bankAccountId"] = this.bankAccountId;
        data["amount"] = this.amount;
        data["method"] = this.method;
        return data;
    }
}

export interface IWithdrawRequestDto {
    sellerId: string;
    walletId: string;
    bankAccountId: string;
    amount: number;
    method: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}